<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>xml语法规则</title>
      <link href="/posts/e2fc93b1.html"/>
      <url>/posts/e2fc93b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="xml读写规则"><a href="#xml读写规则" class="headerlink" title="xml读写规则"></a>xml读写规则</h1><p><img src="https://img-blog.csdnimg.cn/87b5ce6ac7464b68a65e3c2d0b43c220.png"><br>        # 避免 “:” 字符。冒号会被转换为命名空间来使用<br>        表格定义：标签结构<br>        数据对应：指定元素</p><pre><code>所有的标题都用&lt;&gt;来表示。示例&lt;新闻&gt;            &lt;新闻&gt;                        &lt;id&gt;&lt;1001&gt;&lt;\id&gt;                        &lt;标题&gt;&lt;尚......&gt;&lt;\标题&gt;                        &lt;&gt;......                        ......            &lt;\新闻&gt;                    &lt;id&gt;&lt;1002&gt;&lt;\id&gt;                    &lt;标题&gt;&lt;JAVA......&gt;&lt;\标题&gt;                    &lt;&gt;......                    ......&lt;\新闻&gt;    </code></pre><p>XML 被设计用来传输和存储数据。<br>HTML 被设计用来显示数据。</p><h1 id="XML-简化数据传输"><a href="#XML-简化数据传输" class="headerlink" title="XML 简化数据传输"></a>XML 简化数据传输</h1><pre><code>    通过 XML，可以在不兼容的系统之间轻松地交换数据。对开发人员来说，其中一项最费时的挑战一直是在因特网上的不兼容系统之间交换数据。由于可以通过各种不兼容的应用程序来读取数据，以 XML 交换数据降低了这种复杂性。</code></pre><h1 id="XML-简化平台的变更"><a href="#XML-简化平台的变更" class="headerlink" title="XML 简化平台的变更"></a>XML 简化平台的变更</h1><pre><code>    升级到新的系统（硬件或软件平台），总是非常费时的。必须转换大量的数据，不兼容的数据经常会丢失。    XML 数据以文本格式存储。这使得 XML 在不损失数据的情况下，更容易扩展或升级到新的操作系统、新应用程序或新的浏览器。</code></pre><h1 id="XML-标签对大小写敏感"><a href="#XML-标签对大小写敏感" class="headerlink" title="XML 标签对大小写敏感"></a>XML 标签对大小写敏感</h1><pre><code>XML 元素使用 XML 标签进行定义。XML 标签对大小写敏感。在 XML 中，标签 &lt;Letter&gt; 与标签 &lt;letter&gt; 是不同的。必须使用相同的大小写来编写打开标签和关闭标签：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Message&gt;这是错误的。&lt;/message&gt;</span><br><span class="line"></span><br><span class="line">&lt;message&gt;这是正确的。&lt;/message&gt; </span><br></pre></td></tr></table></figure><h1 id="XML-必须正确地嵌套"><a href="#XML-必须正确地嵌套" class="headerlink" title="XML 必须正确地嵌套"></a>XML 必须正确地嵌套</h1><pre><code>在 HTML 中，常会看到没有正确嵌套的元素：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</span><br><span class="line">在 XML 中，所有元素都必须彼此正确地嵌套：</span><br><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure><pre><code>    在上例中，正确嵌套的意思是：由于 &lt;i&gt; 元素是在 &lt;b&gt; 元素内打开的，那么它必须在 &lt;b&gt; 元素内关闭。</code></pre><h1 id="XML-文档必须有根元素"><a href="#XML-文档必须有根元素" class="headerlink" title="XML 文档必须有根元素"></a>XML 文档必须有根元素</h1><pre><code>XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">  &lt;child&gt;</span><br><span class="line">    &lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">  &lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure><h1 id="XML-的属性值须加引号"><a href="#XML-的属性值须加引号" class="headerlink" title="XML 的属性值须加引号"></a>XML 的属性值须加引号</h1><pre><code>与 HTML 类似，XML 也可拥有属性（名称/值的对）。XML 元素可以在开始标签中包含属性，类似 HTML。属性 (Attribute) 提供关于元素的额外（附加）信息。在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;note date=08/08/2008&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;/note&gt; </span><br><span class="line">&lt;note date=&quot;08/08/2008&quot;&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;/note&gt; </span><br></pre></td></tr></table></figure><pre><code>在第一个文档中的错误是，note 元素中的 date 属性没有加引号。</code></pre><h1 id="XML-属性必须加引号"><a href="#XML-属性必须加引号" class="headerlink" title="XML 属性必须加引号"></a>XML 属性必须加引号</h1><pre><code>    属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 标签可以这样写：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;person sex=&quot;female&quot;&gt;</span><br><span class="line">或者这样也可以：</span><br><span class="line"></span><br><span class="line">&lt;person sex=&#x27;female&#x27;&gt;</span><br><span class="line">注释：如果属性值本身包含双引号，那么有必要使用单引号包围它，就像这个例子：</span><br><span class="line"></span><br><span class="line">&lt;gangster name=&#x27;George &quot;Shotgun&quot; Ziegler&#x27;&gt;</span><br><span class="line">或者可以使用实体引用：</span><br><span class="line"></span><br><span class="line">&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt;</span><br></pre></td></tr></table></figure><h1 id="XML-中的注释"><a href="#XML-中的注释" class="headerlink" title="XML 中的注释"></a>XML 中的注释</h1><pre><code>在 XML 中编写注释的语法与 HTML 的语法很相似：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is a comment --&gt; </span><br></pre></td></tr></table></figure><h1 id="在-XML-中，空格会被保留"><a href="#在-XML-中，空格会被保留" class="headerlink" title="在 XML 中，空格会被保留"></a>在 XML 中，空格会被保留</h1><pre><code>HTML 会把多个连续的空格字符裁减（合并）为一个：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML:Hello           my name is David.</span><br><span class="line">输出:Hello my name is David.</span><br><span class="line">在 XML 中，文档中的空格不会被删节。</span><br></pre></td></tr></table></figure><h1 id="XML-文档包含-XML-元素。"><a href="#XML-文档包含-XML-元素。" class="headerlink" title="XML 文档包含 XML 元素。"></a>XML 文档包含 XML 元素。</h1><pre><code>    什么是 XML 元素？XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bookstore&gt;</span><br><span class="line">&lt;book category=&quot;CHILDREN&quot;&gt;</span><br><span class="line">  &lt;title&gt;Harry Potter&lt;/title&gt; </span><br><span class="line">  &lt;author&gt;J K. Rowling&lt;/author&gt; </span><br><span class="line">  &lt;year&gt;2005&lt;/year&gt; </span><br><span class="line">  &lt;price&gt;29.99&lt;/price&gt; </span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;book category=&quot;WEB&quot;&gt;</span><br><span class="line">  &lt;title&gt;Learning XML&lt;/title&gt; </span><br><span class="line">  &lt;author&gt;Erik T. Ray&lt;/author&gt; </span><br><span class="line">  &lt;year&gt;2003&lt;/year&gt; </span><br><span class="line">  &lt;price&gt;39.95&lt;/price&gt; </span><br><span class="line">&lt;/book&gt;</span><br><span class="line">&lt;/bookstore&gt; </span><br></pre></td></tr></table></figure><pre><code>        在上例中，&lt;bookstore&gt; 和 &lt;book&gt; 都拥有元素内容，因为它们包含了其他元素。    &lt;author&gt; 只有文本内容，因为它仅包含文本。    在上例中，只有 &lt;book&gt; 元素拥有属性 (category=&quot;CHILDREN&quot;)。</code></pre><h1 id="XML-元素是可扩展的"><a href="#XML-元素是可扩展的" class="headerlink" title="XML 元素是可扩展的"></a>XML 元素是可扩展的</h1><pre><code>XML 元素是可扩展，以携带更多的信息。</code></pre><p>请看下面这个 XML 例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt; </span><br></pre></td></tr></table></figure><p>让我们设想一下，我们创建了一个应用程序，可将 <to>、<from> 以及 <body> 元素提取出来，并产生以下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">To: George</span><br><span class="line">From: John</span><br><span class="line"></span><br><span class="line">Don&#x27;t forget the meeting!</span><br></pre></td></tr></table></figure><pre><code>想象一下，之后这个 XML 文档作者又向这个文档添加了一些额外的信息：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;note&gt;</span><br><span class="line">&lt;date&gt;2008-08-08&lt;/date&gt;</span><br><span class="line">&lt;to&gt;George&lt;/to&gt;</span><br><span class="line">&lt;from&gt;John&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><pre><code>那么这个应用程序会中断或崩溃吗？不会。这个应用程序仍然可以找到 XML 文档中的 &lt;to&gt;、&lt;from&gt; 以及 &lt;body&gt; 元素，并产生同样的输出。XML 的优势之一，就是可以经常在不中断应用程序的情况进行扩展。</code></pre><h1 id="XML-命名空间提供避免元素命名冲突的方法。"><a href="#XML-命名空间提供避免元素命名冲突的方法。" class="headerlink" title="XML 命名空间提供避免元素命名冲突的方法。"></a>XML 命名空间提供避免元素命名冲突的方法。</h1><pre><code>    命名冲突在 XML 中，元素名称是由开发者定义的，当两个不同的文档使用相同的元素名时，就会发生命名冲突。这个 XML 文档携带着某个表格中的信息：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">   &lt;td&gt;Apples&lt;/td&gt;</span><br><span class="line">   &lt;td&gt;Bananas&lt;/td&gt;</span><br><span class="line">   &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><pre><code>这个 XML 文档携带有关桌子的信息（一件家具）：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">   &lt;name&gt;African Coffee Table&lt;/name&gt;</span><br><span class="line">   &lt;width&gt;80&lt;/width&gt;</span><br><span class="line">   &lt;length&gt;120&lt;/length&gt;</span><br><span class="line">     &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><pre><code>假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 &lt;table&gt; 元素，就会发生命名冲突。XML 解析器无法确定如何处理这类冲突。</code></pre><p>本篇完结！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器视觉、音视频开发</title>
      <link href="/posts/e33939ec.html"/>
      <url>/posts/e33939ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><pre><code>  ipc的英文是ipcamera，没入行之前认为这是嵌入式驱动相关的    工作，后来才知道不是。    基本的过程：采集图像，进行存储，进行传输。    IPC开发为目前嵌入式前沿技术最为密集的领域，    涉及AI，图像识别，人脸识别，动作识别，各种算法等。</code></pre><p><img src="https://img-blog.csdnimg.cn/298304713f9a4ec68b556c30afce0eb1.png"></p><h2 id="1-1、原理"><a href="#1-1、原理" class="headerlink" title="1-1、原理"></a>1-1、原理</h2><p><img src="https://img-blog.csdnimg.cn/2f9aaba10c2743bb8235d62cab7c5b46.png"></p><pre><code>    首先是外景的光线进入镜头，经过一定调焦，打到图像传感器上，也就是sensor，转换成模拟信号，然后通过A/D转换，转换成数字信号。然后经过DSP编码处理。（如果出现模糊等各种情况就可以进行追溯，比如是镜头问题等）    数据消费中的其他指的是传给其他的平台，进行协议的对接。</code></pre><h2 id="1-2、方案介绍"><a href="#1-2、方案介绍" class="headerlink" title="1-2、方案介绍"></a>1-2、方案介绍</h2><pre><code> 当有的人问你，你们公司的摄像机是基于什么方案，什么平台做的外围的配件、电机、摄像头、麦克风等一般都是从供应商拿的，而主控芯片，就是从方案代理公司拿的，所以就是，主控是什么类型的，方案就是基于什么来做的。一般的方案公司有：海思、富瀚、瑞芯微，全志、索尼。所以就形成了一个上下游：芯片制造、芯片代理、方案代理、安防公司。一般从方案公司拿到芯片和sdk。sdk包：具体有arm板文档、uboot、内核、文件系统、busybox、驱动、库、工具，硬件上则是有一个demo板。</code></pre>]]></content>
      
      
      <categories>
          
          <category> AI学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vscode和source insight的快捷键</title>
      <link href="/posts/835d4465.html"/>
      <url>/posts/835d4465.html</url>
      
        <content type="html"><![CDATA[<pre><code>    移动当前行    vscode：alt+方向键    source insight：ctrl+方向键        复制当前行    vscode：Shift + Alt +左右方向，然后复制键    source insight：ctrl+k        选中多个单词    vscode： ctrl + d        左右跳过单词    两者相同：ctrl+左右方向键        向前搜索    两者相同：f3        向后搜索    两者相同：f4    连选    两者相同：按住shift+ctrl+左右方向键    跳转指定行    两者相同：ctrl+g        重新命名变量    vscode： f2跳到报错处vscode：Ctrl + Shift + M添加多个光标vscode： Ctrl + Alt + 上箭头/下箭头关闭当前文件两者相同：ctrl+w将光标从首页移到末尾ctrl+homectrl+encl光标代码滚动vscode：ctrl+上下方向source insight ：alt+方向键光标代码行头行尾移动两者相同：home   encl光标代码块移动vscode：shift+ctrl +\</code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>挂载根文件系统出现错误</title>
      <link href="/posts/643bdf5f.html"/>
      <url>/posts/643bdf5f.html</url>
      
        <content type="html"><![CDATA[<h1 id="挂在busybox的时候出现内核崩溃"><a href="#挂在busybox的时候出现内核崩溃" class="headerlink" title="挂在busybox的时候出现内核崩溃"></a>挂在busybox的时候出现内核崩溃</h1><p><img src="https://img-blog.csdnimg.cn/5095e7285b3c4ab0b1ff7d257f516cc7.png"></p><pre><code>    解决办法， 原因为没有使用交叉编译器进行编译，在Makefile中定义一下</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CROSS_COMPILE ?= arm-linux-gnueabihf-</span><br><span class="line"></span><br><span class="line">ARCH ？= arm</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程的退出及信息打印</title>
      <link href="/posts/7a4978d4.html"/>
      <url>/posts/7a4978d4.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、错误处理"><a href="#1、错误处理" class="headerlink" title="1、错误处理"></a>1、错误处理</h1><pre><code>        程序编写错误，一般会在编译的时候展示错误信息，但是如    果是用户的操作产生的错误，往往无法展示，所以就需一种    展示错误信息的方法。</code></pre><p><code>需要指定的输出函数fprintf</code></p><h2 id="1-1、三个流"><a href="#1-1、三个流" class="headerlink" title="1-1、三个流"></a>1-1、三个流</h2><pre><code>    在程序创建的同时，会默认开启三个流，分别是标准输入stdin，标准    输出stdout和标准错误stdetr。stdin默认指向键盘。stdout和stderr默认输    出到屏幕。    stdout和stderr区别在于：stderr被设计为无缓冲的输出，即不需要填满缓冲    在进行io操作。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fprintf(stdout,&quot;hello &quot;);</span><br><span class="line">fprintf(stderr,&quot;world!&quot;);</span><br></pre></td></tr></table></figure><pre><code>    结果就是stdout会放到缓冲区，需要回车才会进行实际的操作，    结果就是world！hello。</code></pre><h2 id="1-2、在errno-h中定义了很多错误类型"><a href="#1-2、在errno-h中定义了很多错误类型" class="headerlink" title="1-2、在errno.h中定义了很多错误类型"></a>1-2、在errno.h中定义了很多错误类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define ECHILD 10</span><br><span class="line">#define EAGAIN 11</span><br><span class="line">#define ENOMEM 12</span><br><span class="line">#define EACCES 13</span><br><span class="line">#define EFAULT 14</span><br><span class="line">#define EBUSY 16</span><br><span class="line">#define EEXIST 17</span><br><span class="line">#define EXDEV 18</span><br><span class="line">#define ENODEV 19</span><br><span class="line">#define ENOTDIR 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-3、错误处理"><a href="#1-3、错误处理" class="headerlink" title="1-3、错误处理"></a>1-3、错误处理</h2><h3 id="1-3-1、perror"><a href="#1-3-1、perror" class="headerlink" title="1-3-1、perror"></a>1-3-1、perror</h3><pre><code>    fprintf(stderr, &quot;错误号: %d\n&quot;, errno);如果是这样输出的话，    只输出了一个错误编号。所以还需要其他的函数配合。    用perror输出错误信息，不需要传递错误编号，会根据当前的errno主动打印。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">perror(&quot;通过 perror 输出错误&quot;);</span><br><span class="line">// 假设此时errno指向的错误信息为未找到指定文件</span><br><span class="line">// 那么此时屏幕中会打印出:</span><br><span class="line">// 通过 perror 输出错误: No such file or directory</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-3-2-、strerror"><a href="#1-3-2-、strerror" class="headerlink" title="1-3-2 、strerror"></a>1-3-2 、strerror</h3><pre><code>    sterror是将错误号在头文件中搜索错误，并返回一个指向错误消息的字符    串的指针，该错误消息字符串用于描述当前程序的错误。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fprintf(stderr, &quot;Error: %s\n&quot;, strerror(errno));</span><br><span class="line">// 打印结果为</span><br><span class="line">//Error: No such file or directory</span><br></pre></td></tr></table></figure><h1 id="2、函数退出：exit、-exit-、return"><a href="#2、函数退出：exit、-exit-、return" class="headerlink" title="2、函数退出：exit、_exit 、return"></a>2、函数退出：exit、_exit 、return</h1><pre><code>    _exit（int status）作用是结束进程,status表示进程结束时的状态，    0表示正常，1标识非正常。    exit（int status）作用是结束进程,status表示进程结束时的状态，    0表示正常，1标识非正常。</code></pre><p><img src="https://img-blog.csdnimg.cn/bf73e5d4069e4250be51f28cdb946983.png"></p><pre><code>        终止处理函数需要提前注册    _exit函数处理不会调用终止处理函数</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void bye(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*********终止处理函数注册************/</span><br><span class="line">    atexit(bye);</span><br><span class="line">    printf(&quot;你好\r\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    _exit(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">ygc@ygc:~/network/03_exit_and_exit$ ./a.out </span><br><span class="line">你好</span><br></pre></td></tr></table></figure><pre><code>    终止处理函数需要提前注册    exit函数终止进程会调用终止处理函数</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void bye(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*********终止处理函数注册************/</span><br><span class="line">    atexit(bye);</span><br><span class="line">    printf(&quot;你好\r\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    exit(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">ygc@ygc:~/network/03_exit_and_exit$ ./a.out </span><br><span class="line">你好</span><br><span class="line">再见</span><br></pre></td></tr></table></figure><pre><code>    当注册多个终止处理函数时，执行的顺序是反着的</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void bye1(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见1\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bye2(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见2\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bye3(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见3\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*********终止处理函数注册************/</span><br><span class="line">    atexit(bye1);</span><br><span class="line">    atexit(bye2);</span><br><span class="line">    atexit(bye3);</span><br><span class="line">    printf(&quot;你好\r\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    exit(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">执行结果：</span><br><span class="line">ygc@ygc:~/network/03_exit_and_exit$ ./a.out </span><br><span class="line">你好</span><br><span class="line">再见3</span><br><span class="line">再见2</span><br><span class="line">再见1</span><br></pre></td></tr></table></figure><h2 id="2-1、缓存的问题"><a href="#2-1、缓存的问题" class="headerlink" title="2-1、缓存的问题"></a>2-1、缓存的问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;你好&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    _exit(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">ygc@ygc:~/network/04_huancun$ ./a.out </span><br><span class="line">ygc@ygc:~/network/04_huancun$ </span><br><span class="line">去掉换行符不会打印信息，而exit可以正常打印，这里不再代码测试</span><br></pre></td></tr></table></figure><h2 id="2-2、exit和return之间的区别"><a href="#2-2、exit和return之间的区别" class="headerlink" title="2-2、exit和return之间的区别"></a>2-2、exit和return之间的区别</h2><pre><code>1、exit是一个库函数，而return是一个c语言语句2、exit最终会进入到内核，把控制权交给内核，而return则是把控制全交给上层调用。return终止进程可以刷新缓冲。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    printf(&quot;你好&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    //exit(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">ygc@ygc:~/network/04_huancun$ ./a.out </span><br><span class="line">你好ygc@ygc:~/network/04_huancun$ </span><br></pre></td></tr></table></figure><pre><code>    此外也可以调用终止处理函数</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void bye1()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见1\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bye2()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见2\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bye3()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见3\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*********终止处理函数注册************/</span><br><span class="line">    atexit(bye1);</span><br><span class="line">    atexit(bye2);</span><br><span class="line">    atexit(bye3);</span><br><span class="line">    printf(&quot;你好\r\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">   // exit(0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~/network/04_huancun$ gcc exit.c </span><br><span class="line">ygc@ygc:~/network/04_huancun$ ./a.out </span><br><span class="line">你好</span><br><span class="line">再见3</span><br><span class="line">再见2</span><br><span class="line">再见1</span><br></pre></td></tr></table></figure><h2 id="2-3、exit和abort之间有什么区别"><a href="#2-3、exit和abort之间有什么区别" class="headerlink" title="2-3、exit和abort之间有什么区别"></a>2-3、exit和abort之间有什么区别</h2><pre><code>    1、exit用于正常进程的终止，abort用于异常终止进程。    正常的进程终止会清理缓冲，而abort则不会进行清理，而是    执行sigabt信号系统的默认处理操作。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void bye1()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见1\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bye2()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见2\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void bye3()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;再见3\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    /*********终止处理函数注册************/</span><br><span class="line">    atexit(bye1);</span><br><span class="line">    atexit(bye2);</span><br><span class="line">    atexit(bye3);</span><br><span class="line">    printf(&quot;你好\r\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">   // exit(0);</span><br><span class="line">abort();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">ygc@ygc:~/network/04_huancun$ ./a.out </span><br><span class="line">你好</span><br><span class="line">已放弃 (核心已转储)</span><br><span class="line">ygc@ygc:~/network/04_huancun$ </span><br></pre></td></tr></table></figure><pre><code>文章结束</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux c 开发编程</title>
      <link href="/posts/69453faf.html"/>
      <url>/posts/69453faf.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、系统调用和库函数"><a href="#1、系统调用和库函数" class="headerlink" title="1、系统调用和库函数"></a>1、系统调用和库函数</h1><h2 id="1-1、库函数由两类函数组成"><a href="#1-1、库函数由两类函数组成" class="headerlink" title="1-1、库函数由两类函数组成"></a>1-1、库函数由两类函数组成</h2><pre><code>        1、不需要调用系统调用                不需要切换到内核空间即可完成函数的全部功能，并且将结果反馈给应用程序，        如strcpy、bzero等字符串操作函数。                2、需要调用系统调用          需要切换到内核空间，这类函数通过封装的系统调用去实现相应的功能，          如printf、fread等          </code></pre><h2 id="1-2、系统调用与库函数的关系"><a href="#1-2、系统调用与库函数的关系" class="headerlink" title="1-2、系统调用与库函数的关系"></a>1-2、系统调用与库函数的关系</h2><pre><code>    并不是所有系统调用都被封装成为库函数，系统提供的很多功能必须通过系统调用才能实现。    也就是大部分的库函数都是由系统调用封装而来。只不过库函数拥有缓冲区，减少了系统调用    的次数</code></pre><h2 id="1-3、特点"><a href="#1-3、特点" class="headerlink" title="1-3、特点"></a>1-3、特点</h2><pre><code>    系统调用是需要时间的，频繁的系统调用会降低程序的运行效率。    当运行内核代码时，cpu工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然    后转入内核态工作。    结束调用后又返回用户态。</code></pre><h3 id="1-3-1、库函数的好处"><a href="#1-3-1、库函数的好处" class="headerlink" title="1-3-1、库函数的好处"></a>1-3-1、库函数的好处</h3><pre><code>    库函数访问文件的时候需要根据需要设置不同类型的缓存区，从而减少了直接调用io系统调用    的次数，提高了访问的效率。</code></pre><p><img src="https://img-blog.csdnimg.cn/b6c02c87ea9b49b2a47989e0640f1845.png"></p><pre><code>    如：应用程序调用printf时，如下图</code></pre><p><img src="https://img-blog.csdnimg.cn/7c2c4e37a4d44f019eb6cd5778eff6d4.png"></p><h1 id="2、进程"><a href="#2、进程" class="headerlink" title="2、进程"></a>2、进程</h1><pre><code>    当一个系统启动后，会先后创建3个文件描述符。0、1、2.</code></pre><h2 id="2-1、进程的定义"><a href="#2-1、进程的定义" class="headerlink" title="2-1、进程的定义"></a>2-1、进程的定义</h2><pre><code>    程序：        程序是存放在存储介质上 一个可执行文件。    进程：         程序是静态的，进程是动态的，进程是在内存中运行的。                  程序是一些指令的有序集合，而进程是执行程序的过程。         进程的状态是变化的。只要程序运行，此时就是进程，程序每运行一次，就会创建一个进程。         进程拥有自己独立的处理环境和系统资源（处理器、存储器、io设备、数据、程序）。</code></pre><h2 id="2-2、进程的状态及转换"><a href="#2-2、进程的状态及转换" class="headerlink" title="2-2、进程的状态及转换"></a>2-2、进程的状态及转换</h2><pre><code>    进程可以划分为三中状态：        就绪态：进程已经具备执行的一切条件，正在等待分配cpu的处理时间。        执行态：该进程正在占用cpu运行。        等待态：进程因不具备某些执行条件而暂时无法继续执行的状态。比如scanf输入，在没有输入        时就是等待态。</code></pre><h2 id="2-3、进程的调度机制"><a href="#2-3、进程的调度机制" class="headerlink" title="2-3、进程的调度机制"></a>2-3、进程的调度机制</h2><pre><code>    时间片轮转：如单核cpu，同一时间段内只能运行一个进程，下一个时间段运行第二个进程。    上下文切换：就是比如上部分程序运行了，下部分程序还没有运行被切换到另一个进程中去了。</code></pre><h2 id="2-4、进程控制块"><a href="#2-4、进程控制块" class="headerlink" title="2-4、进程控制块"></a>2-4、进程控制块</h2><pre><code>    进程控制块就是一个保存进程信息=结构体，存放在task_struct结构体中。</code></pre><h2 id="2-5、进程号"><a href="#2-5、进程号" class="headerlink" title="2-5、进程号"></a>2-5、进程号</h2><pre><code>    每一个进程都由一个进程号来标识，类型为pid_t，凡时下划线为_t的数据类型都称为类整型。    进程号是唯一的，但是在一个进程终止后可以重复使用。进程号是由操作系统随机给程序分配的。    </code></pre><p><code>凡时下划线为_t的数据类型都称为类整型.</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ajx</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ead530fd35a45e786ec14387c221718.png"></p><pre><code>    PPID：当前进程的父进程的进程号    PID：当前进程的进程号    PGID：当前进程组所在的进程组ID，进程组是一个或者多个进程的集合，相互关联，        进程组可以接收同一个终端信号。    COMMAND：当前进程的名字        特殊的进程号：            在linux系统中进程号由0开始。            进程号0和1由进程创建。            进程号0通常称之为调度进程，交换进程。            进程号为1的进程通常是init进程。init是所有进程的祖先。            除了调度进程外，所有进程都由init进程直接或间接创建。        父子进程的关系就是由谁创建了谁的关系。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux下提供三个获得进程号的函数 </span><br><span class="line">pid_t getpid()</span><br><span class="line">pid_t getppid()</span><br><span class="line">pid_t getpgid( pid_t)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/******* 示例 *********/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">/********* 获取当前进程的进程号  **********/</span><br><span class="line">printf(&quot;pid = %d\n&quot;,getpid());</span><br><span class="line">/************ 获取当前进程的父进程id *************/</span><br><span class="line">printf(&quot;ppid = %d\n&quot;,getppid());</span><br><span class="line">/************ 获取当前进程所在组的id  *************/</span><br><span class="line">printf(&quot;pgid = %d\n&quot;,getpgid(getpid()));</span><br><span class="line">while(1)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6、进程的创建fork函数"><a href="#2-6、进程的创建fork函数" class="headerlink" title="2-6、进程的创建fork函数"></a>2-6、进程的创建fork函数</h2><pre><code>    创建进程的方法主要是调用一下两个函数：    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">pid_t fork()</span><br><span class="line">pid_t fork()</span><br></pre></td></tr></table></figure><pre><code>    使用fork函数后：</code></pre><p><img src="https://img-blog.csdnimg.cn/7f766c609fb54de3b78cf29a746de36e.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    /******  通过fork函数创建一个子进程 *******/</span><br><span class="line">     /***********     **************/</span><br><span class="line"> #if 0   </span><br><span class="line"> fork();</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line"> #endif</span><br><span class="line"> /****** 通过fork函数的返回值来确定父子进程的独立区代码 ********/</span><br><span class="line"> /********  父子进程是来回交替运行的，谁先允许，后允许，这个是不确定的   **************/</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;parent :pid = %d,ppid = %d\r\n&quot;,getpid(),getppid());    </span><br><span class="line">        printf(&quot;pid = %d\r\n&quot;,pid);</span><br><span class="line">        printf(&quot;this is parent\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;**********************************&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     while (1)</span><br><span class="line">     &#123;</span><br><span class="line">        printf(&quot;son :pid = %d,ppid = %d\r\n&quot;,getpid(),getppid());   </span><br><span class="line">        printf(&quot;this is child\n&quot;);</span><br><span class="line">        sleep(2);</span><br><span class="line">        printf(&quot;**********************************&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int a = 1;</span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    /******  通过fork函数创建一个子进程 *******/</span><br><span class="line">     /***********     **************/</span><br><span class="line"> #if 0   </span><br><span class="line"> fork();</span><br><span class="line">    printf(&quot;hello world\n&quot;);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line"> #endif</span><br><span class="line"> /****** 通过fork函数的返回值来确定父子进程的独立区代码 ********/</span><br><span class="line"> /********  父子进程是来回交替运行的，谁先允许，后允许，这个是不确定的   **************/</span><br><span class="line">    int b = 2;</span><br><span class="line">    static int c = 3;</span><br><span class="line">    /************** 同时，在fork之前的数据，子进程都会保留，后面无论父进程怎么变（</span><br><span class="line">      堆区栈区数据区），都不会影响子进程***************/</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">        c++;</span><br><span class="line">        printf(&quot;this is parent a = %d ,b = %d ,c = %d\r\n&quot;, a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">     &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">     printf(&quot;this is son a = %d ,b = %d ,c = %d\r\n&quot;,a, b, c);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">while(1);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行结果</span><br><span class="line">ygc@ygc:~/network/07_fork2$ ./a.out </span><br><span class="line">this is parent a = 2 ,b = 3 ,c = 4</span><br><span class="line">this is son a = 1 ,b = 2 ,c = 3</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><pre><code>    从上面可以看出，子进程会在fork之前做数据的继承    而有内核空间，磁盘空间是进程所共有的，改变偏移量，    会将偏移指针保存在内核中，所以父进程改变的偏移量会继承到子进程中。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(&quot;file.txt&quot;,O_RDONLY)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;open file.txt&quot;);</span><br><span class="line">        goto filed_open;</span><br><span class="line">    &#125; </span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;filed_fork&quot;);</span><br><span class="line">        goto filed_fork;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        char buf[32] = &quot; &quot;;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        printf(&quot;this is parent\r\n&quot;);</span><br><span class="line">        if(read(fd,buf,30) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;filed_read\r\n&quot;);</span><br><span class="line">            goto filed_read;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;buf = [%s]\r\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       sleep(1);</span><br><span class="line"></span><br><span class="line">        printf(&quot;this is son\r\n&quot;);    </span><br><span class="line"></span><br><span class="line">         char buf[32] = &quot; &quot;;</span><br><span class="line">        memset(buf,0,sizeof(buf));</span><br><span class="line">        printf(&quot;this is parent\r\n&quot;);</span><br><span class="line">        if(read(fd,buf,30) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;filed_read\r\n&quot;);</span><br><span class="line">            goto filed_read;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;buf = [%s]\r\n&quot;,buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    while(1);</span><br><span class="line">    return 0;</span><br><span class="line">    filed_read:</span><br><span class="line">    close(fd);</span><br><span class="line">    filed_fork:</span><br><span class="line">    filed_open:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-7、进程的挂起"><a href="#2-7、进程的挂起" class="headerlink" title="2-7、进程的挂起"></a>2-7、进程的挂起</h2><pre><code>    进程在一段时间内没有任何的动作，称为进程的挂起。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubsigned int sleep(unsigned int sec);</span><br></pre></td></tr></table></figure><pre><code>功能：    进程挂起指定的秒数，直到指定的时间用完或受到信号才解除挂起。返回值：  指定时间返回0；若有信号中断则返回剩余的秒数。注意： 结束挂起并不会立刻执行，而是切换到就绪状态。</code></pre><h2 id="2-8、进程的等待"><a href="#2-8、进程的等待" class="headerlink" title="2-8、进程的等待"></a>2-8、进程的等待</h2><pre><code>Linux进程有时候需要简单的进程之间的同步，如父进程等待子进程的结束。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">两个函数</span><br><span class="line">wait（）、waitpid（）</span><br><span class="line">如果父进程先结束，会打印终端提示符</span><br><span class="line">有返回值。</span><br><span class="line">子进程可以通过exit和_exit发送退出状态。</span><br><span class="line">也可以用宏来取出子进程的退出信息</span><br><span class="line">WIFEXITED(status)</span><br><span class="line">如果子进程是正常终止的，取出的字段值非零。</span><br><span class="line">WEXITSTATUS(status)</span><br><span class="line">返回子进程的退出状态，退出状态保存在status变量8~16位。在</span><br><span class="line">使用前先用宏判断WIFEXITED判断子进程是否正常退出，正常退</span><br><span class="line">出才能使用此宏</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/******** wait一个简单的例子，当子进程执行完毕，才执行父进程，wait没有参数 *************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;hello\r\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     &#123;  /***** 子进程的推出状态必须是exit或者_exit退出 ******/</span><br><span class="line">        int status = 0;</span><br><span class="line">        wait(&amp;status); </span><br><span class="line">        printf(&quot;world\r\n&quot;);</span><br><span class="line">        /*****   执行 WEXITSTATUS前必须先执行WIFEXITED ******/</span><br><span class="line">        if (WIFEXITED(status)) </span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;this is son return status %d\r\n&quot;, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    另外还有一个函数也可以实现进程的等待waitpid</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*******想要实现和wait一样的功能******/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid &lt; 0)</span><br><span class="line">    &#123;   </span><br><span class="line">        perror(&quot;fork error&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;hello\r\n&quot;);</span><br><span class="line">        sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">     </span><br><span class="line">     &#123;  /***** 子进程的推出状态必须是exit或者_exit退出 ******/</span><br><span class="line">        int status = 0;</span><br><span class="line">        waitpid(pid,NULL,0); </span><br><span class="line">        printf(&quot;world\r\n&quot;);</span><br><span class="line">        /*****   执行 WEXITSTATUS前必须先执行WIFEXITED ******/</span><br><span class="line">       // if (WIFEXITED(status)) </span><br><span class="line">       // &#123;</span><br><span class="line">       //     printf(&quot;this is son return status %d\r\n&quot;, WEXITSTATUS(status));</span><br><span class="line">       // &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-1、注意"><a href="#2-8-1、注意" class="headerlink" title="2-8-1、注意"></a>2-8-1、注意</h3><pre><code>wait可以回收子进程的资源</code></pre><h4 id="2-8-2、特殊进程"><a href="#2-8-2、特殊进程" class="headerlink" title="2-8-2、特殊进程"></a>2-8-2、特殊进程</h4><pre><code>僵尸进程    子进程已经运行结束，父进程没有电泳wait或者waitpid。    进行子进程资源的回收，就称为僵尸进程。孤儿进程    父进程运行结束，但子进程未运行结束的进程。守护进程（精灵进程）    守护进程是个特殊的孤儿进程，这种进程脱离了终端，在后台运行。</code></pre><h2 id="2-9、进程的终止"><a href="#2-9、进程的终止" class="headerlink" title="2-9、进程的终止"></a>2-9、进程的终止</h2><pre><code>return是退出函数，并不是退出进程Linux下可以通过 ：void  exit(int value)void _exit(int value)区别在于：exit为库函数，exit为系统调用在文章《进程的退出及错误打印》中有具体用法。</code></pre><h2 id="2-10、进程退出清理"><a href="#2-10、进程退出清理" class="headerlink" title="2-10、进程退出清理"></a>2-10、进程退出清理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int atexit（void（*function））</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux中断</title>
      <link href="/posts/835d4465.html"/>
      <url>/posts/835d4465.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、上半部和下半部"><a href="#1、上半部和下半部" class="headerlink" title="1、上半部和下半部"></a>1、上半部和下半部</h1><p> 上半部是时间处理快、对硬件进行处理、或者不希望被其他的中断打断。</p><p>处理以上的三点外可以放在下半部。</p><h2 id="1-1、软中断"><a href="#1-1、软中断" class="headerlink" title="1-1、软中断"></a>1-1、软中断</h2><p>软中断需要在编译内核的时候注册，使用函数open——softir，注册以后使用raise——sonftirq触发，软中断尽可能不去使用。</p><h2 id="1-2、tasklet"><a href="#1-2、tasklet" class="headerlink" title="1-2、tasklet"></a>1-2、tasklet</h2><p>需要用到上半部，上半部的处理函数重点是调用tasklet_schedule。</p><p>1、定义一个tasklet函数。</p><p>2、初始化、重点是设置对应的处理函数。</p><h2 id="1-3、工作队列"><a href="#1-3、工作队列" class="headerlink" title="1-3、工作队列"></a>1-3、工作队列</h2><h1 id="2、设备树中的中断节点信息"><a href="#2、设备树中的中断节点信息" class="headerlink" title="2、设备树中的中断节点信息"></a>2、设备树中的中断节点信息</h1><p>比如在一个gpio中断中：</p><p>interrupt-parent指定父中断，interrupts第一个cells就是gpio编号，因此比如gpio_io00，1，2，4，8，所代表的是触发方式。可以在绑定的文档中查看。</p><h1 id="3、程序编写"><a href="#3、程序编写" class="headerlink" title="3、程序编写"></a>3、程序编写</h1><p>第一步、先要在设备书中添加中断的节点信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">key0&#123;</span><br><span class="line"></span><br><span class="line">​        compatible = <span class="string">&quot;wesker,led&quot;</span>;</span><br><span class="line"></span><br><span class="line">​        pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">​        pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key0&gt;;</span><br><span class="line"></span><br><span class="line">​        beep-gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line"></span><br><span class="line">​        interrupt-parent = &lt;&amp;gpio1&gt;</span><br><span class="line"></span><br><span class="line">​        interrupts = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;</span><br><span class="line"></span><br><span class="line">​        status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line"></span><br><span class="line">​    &#125;;</span><br></pre></td></tr></table></figure><p>第二步、编写驱动程序</p>]]></content>
      
      
      <categories>
          
          <category> 驱动 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>报隐式函数的报错</title>
      <link href="/posts/ac405b50.html"/>
      <url>/posts/ac405b50.html</url>
      
        <content type="html"><![CDATA[<h1 id="隐式函数错误一般原因"><a href="#隐式函数错误一般原因" class="headerlink" title="隐式函数错误一般原因"></a>隐式函数错误一般原因</h1><p>写驱动的时候经常遇到报隐式函数的报错，很麻烦，查找了很多原因</p><p>一般是函数拼写错误</p>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/posts/50daec4.html"/>
      <url>/posts/50daec4.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、计算机网络发展"><a href="#1、计算机网络发展" class="headerlink" title="1、计算机网络发展"></a>1、计算机网络发展</h1><pre><code>    最早的计算机网络是ARPA，但是最早的ARPA无法连接不同类型的计算机和不同的操作系统。</code></pre><h2 id="1-1、数据交换"><a href="#1-1、数据交换" class="headerlink" title="1-1、数据交换"></a>1-1、数据交换</h2><pre><code>    通过标有地址的分组进行路由选择传输数据，使得通信通道仅在传送期间被占用的一种交换方式。</code></pre><p><img src="https://img-blog.csdnimg.cn/5cd87be15c474bb4a11ea5605aacba60.png"></p><h2 id="1-2、交换方式"><a href="#1-2、交换方式" class="headerlink" title="1-2、交换方式"></a>1-2、交换方式</h2><pre><code>    交换的方式为存储转发，节点收到分组，先暂时存储下来，再检查它的头部，然后按照首部中的地址，    找到合适的节点转发出去。</code></pre><p><img src="https://img-blog.csdnimg.cn/38f63356e5bd4db8bc28ae74904b60b8.png"></p><h3 id="1-2-3、特点"><a href="#1-2-3、特点" class="headerlink" title="1-2-3、特点"></a>1-2-3、特点</h3><pre><code>    1、以分组作为传输单位。    2、独立选择转发路由。    3、逐段占用，动态分配传输带宽。</code></pre><h2 id="1-3、发展过程"><a href="#1-3、发展过程" class="headerlink" title="1-3、发展过程"></a>1-3、发展过程</h2><pre><code>    从单个ARPA发展为tcp/ip的ARPAnei的标注协议。</code></pre><h1 id="2、英特网的结构"><a href="#2、英特网的结构" class="headerlink" title="2、英特网的结构"></a>2、英特网的结构</h1><h2 id="2-1、三级结构英特网"><a href="#2-1、三级结构英特网" class="headerlink" title="2-1、三级结构英特网"></a>2-1、三级结构英特网</h2><p><img src="https://img-blog.csdnimg.cn/f7f7b18bdcc34f3da0c9c8a8cb7bf3c5.png"></p><pre><code>    每个国家都有一个主干网，然后层级下发。</code></pre><h2 id="2-2、多级英特网"><a href="#2-2、多级英特网" class="headerlink" title="2-2、多级英特网"></a>2-2、多级英特网</h2><p><img src="https://img-blog.csdnimg.cn/cbcbf5759d5b4650927a741f82519b69.png"></p><h1 id="3、TCP-x2F-IP协议族"><a href="#3、TCP-x2F-IP协议族" class="headerlink" title="3、TCP&#x2F;IP协议族"></a>3、TCP&#x2F;IP协议族</h1><h2 id="3-1、分层结构"><a href="#3-1、分层结构" class="headerlink" title="3-1、分层结构"></a>3-1、分层结构</h2><pre><code>    由来：主要是为了解决不同计算机之间和不同操作系统直接的差异，就进行分层，只需要保证某些层次是一样的，    就可以进行通讯。</code></pre><p><img src="https://img-blog.csdnimg.cn/ef551d0f79a44d0282306cd494cad2d2.png"></p><pre><code>    最造的分层体系是osi开放系统互联模型，是由国际化标准组织（iso）指定，由于osi过于    复杂，所以到现在也没有使用，而是使用的是TCP/IP协议族。    应用层：应用程序沟通的 例如：FTP、HTTP、Telnet等。    FTP：文件传输协议，如app的上传和下载功能。    HTTP：超文本协议，通过浏览器访问其他网站，必须通过http协议。    传输层：提供程序间数据的传输逻辑通讯，例如TCP、UDP。    网络层：提供基本的数据包传送功能，最大可能的能让每个数据报都能到达主机，例如IP、ICMP等。    IP：用来找到目的主机。    链路层：负责数据帧的发送和接收。一个数据称为一帧数据。    每层完成自己的任务，最终完成不同层次的处理完成数据的收发。</code></pre><p><img src="https://img-blog.csdnimg.cn/ca77435a4b2149d89386f95c286a87b2.png"></p><pre><code>    上图的ARP协议是通过对方的ip地址找对方MAC地址，而RARP则是通过MAC地址找ip地址。    数据是从应用层到传输层，一直到链路层，整体把数据交给链路层之后，将数据传给对方，然后最后层    层解封。</code></pre><h2 id="3-2、-IP协议"><a href="#3-2、-IP协议" class="headerlink" title="3-2、 IP协议"></a>3-2、 IP协议</h2><pre><code>    特指为实现一个相互连接的网络系统上从源地址到目的地传输数据包所提供的必要协议。也称为网际协议。特点：不可靠：他不能保证ip数据包能够成功的到达它的目的地，只能尽力而为的传输服务。        无连接：ip并不维护后数据包的状态信息。每个数据包是相互独立的。ip数据包可以不安发送数据发送。        ​ip数据包中有它的发送地址ip和接收它的ip主机地址。</code></pre><h2 id="3-3、tcp协议简介"><a href="#3-3、tcp协议简介" class="headerlink" title="3-3、tcp协议简介"></a>3-3、tcp协议简介</h2><pre><code>    tcp协议是面向连接的，可靠的传输层通讯协议。        功能：提供不同主机上的进程间通讯。    特点：        1、建立链接-&gt;使用链接-&gt;释放链接（虚电路）。        2、tcp数据包中包含序号和确认序号。        3、对包经行排序并检错，而损坏的包可以被重传。    服务对象        需要高度可靠并面向连接的服务。                如：http、ftp、smtp等。                smtp为简单邮件传输协议。</code></pre><h2 id="3-4、udp协议简介"><a href="#3-4、udp协议简介" class="headerlink" title="3-4、udp协议简介"></a>3-4、udp协议简介</h2><pre><code>    udp是一种面向无连接的传输层通讯协议。也称用户数据报协议。    功能：            提供不同主机上的进程间通讯。    特点：        1、发送数据前不需要建立链接。        2、不对数据包的顺序进行检查。        3、没有错误检测和重传机制。    服务对象：    主要用于查询应答服务。    如：nfs、ntp、dns等</code></pre><h2 id="3-5、mac地址"><a href="#3-5、mac地址" class="headerlink" title="3-5、mac地址"></a>3-5、mac地址</h2><pre><code>    mac地址类似于身份证号。出场的时候标出，理论上全球唯一。</code></pre><p><img src="https://img-blog.csdnimg.cn/1941966561584d70ae12c4c6b66bb977.png"></p><pre><code>    组成：以太网内的MAC地址是一个48bit的值。mac地址是可以修改的，但是一般情况下不建议修改mac地址。    总共分成6组，通过 : 隔开，前三组称为厂商ID，后三组称为设备ID。    如果是我们自己识别的话是分组识别，如果是输入给计算机的话就是48位的值。</code></pre><h2 id="3-6、ip地址"><a href="#3-6、ip地址" class="headerlink" title="3-6、ip地址"></a>3-6、ip地址</h2><pre><code>    ip地址是一种internet上的主机编址，也称为网际协议地址。    ip地址在网络中具有唯一标识。</code></pre><h3 id="3-6-1、IP地址的分类"><a href="#3-6-1、IP地址的分类" class="headerlink" title="3-6-1、IP地址的分类"></a>3-6-1、IP地址的分类</h3><pre><code>    ipv4，占32位    ipv6，占128位</code></pre><h4 id="3-6-1-1、ipv4组成"><a href="#3-6-1-1、ipv4组成" class="headerlink" title="3-6-1-1、ipv4组成"></a>3-6-1-1、ipv4组成</h4><pre><code>    ipv4一般使用点分十进制字符串来标识，如192.168.1.135。</code></pre><h3 id="3-6-2、ip组成"><a href="#3-6-2、ip组成" class="headerlink" title="3-6-2、ip组成"></a>3-6-2、ip组成</h3><pre><code>    使用32位，有&#123;网络id，主机id&#125;两部分组成    子网：IP地址中由1覆盖的连续位    主机：由ip地址中0覆盖的连续位</code></pre><p><img src="https://img-blog.csdnimg.cn/5ad8577b9e6840d9b84fe228898a2c5a.png"></p><pre><code>    子网ID不同的网络不能直接通讯，如果要通讯要通过路由器转发。    主机id全为0表示网段地址。    主机id全为1的ip地址表示该网段的广播地址。    如192.168.1.0为表示网段，192.168.1.255为广播地址。</code></pre><h3 id="3-6-3、ipv4的地址分类（依据前8位进行区分）"><a href="#3-6-3、ipv4的地址分类（依据前8位进行区分）" class="headerlink" title="3-6-3、ipv4的地址分类（依据前8位进行区分）"></a>3-6-3、ipv4的地址分类（依据前8位进行区分）</h3><pre><code>    A类地址：默认8位子网id，第一位为0，前8位00000000 - 0111 1111，    范围0.x.x.x - 127.x.x.x    B类地址：默认16位子网id，前两位为10，前8位1000 0000  -  1011 1111，    范围128.x.x.x  -  191.x.x.x    C类地址：默认24位子网id，前三位为110，前8位为1100 0000   -  1101 1111 ，    范围192 .x.x.x  -  223.x.x.x    D类地址：前四位为1110，多播地址，前8位1110 0000 -  1110 1111，    范围224.x.x.x  -  239.x.x.x    E类地址：前五位为1111 0，保留为今后使用，前八位为1111 0000  -  1111 1111 ，    范围240 .x.x.x -  255.x.x.x</code></pre><h3 id="3-6-4、私有ip"><a href="#3-6-4、私有ip" class="headerlink" title="3-6-4、私有ip"></a>3-6-4、私有ip</h3><pre><code>    公有ip(可直接联网)：        经由internic同意规划的ip    私有ip（不可直接连接internet）：        主要用于局域网络内的主机联机规划</code></pre><p>​<img src="https://img-blog.csdnimg.cn/c762dbe1e3404ba29225baaf2ec4e34e.png"></p><h3 id="3-6-5、回环ip地址"><a href="#3-6-5、回环ip地址" class="headerlink" title="3-6-5、回环ip地址"></a>3-6-5、回环ip地址</h3><pre><code>    通常127.0.0.1称为回环地址    功能：    主要是测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和ip协议的安装没有问题。    注意：    127.0.0.1----127.255.255.254中的任何地址都将回环到本机的地址中，不属于任何一个有类别的地址类，    它代表着设备的本地接口。</code></pre><h3 id="3-6-6、子网掩码"><a href="#3-6-6、子网掩码" class="headerlink" title="3-6-6、子网掩码"></a>3-6-6、子网掩码</h3><p>子网掩码又称为网络掩码、地址掩码是一个有32位由1和0组成的数值，并且1和0分别连续。</p><p>作用：</p><p>​用于指明ip地址中那些是子网，那些是主机号。</p><p>特点：</p><p>​必须结合ip地址一起使用，不能单独存在。</p><p>​ip地址中由子网掩码中1覆盖的连续位为子网id，其余为主机id。</p><p><img src="https://img-blog.csdnimg.cn/c67cd045ae8f421ba831a9973d9f5065.png"></p><h2 id="3-7、端口"><a href="#3-7、端口" class="headerlink" title="3-7、端口"></a>3-7、端口</h2><h3 id="3-7-1、端口概述"><a href="#3-7-1、端口概述" class="headerlink" title="3-7-1、端口概述"></a>3-7-1、端口概述</h3><pre><code>    tcp/ip采用端口标识通信进程，用于区分一个系统里的多个进程。    特点：    1、对于同一个端口，在不同的系统中对应着不同的进程。    2、对于同一个系统，一个端口只能被一个进程拥有。    3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，    进程送交传输层的数据也通过该端口被送出。</code></pre><h3 id="3-7-2、端口号"><a href="#3-7-2、端口号" class="headerlink" title="3-7-2、端口号"></a>3-7-2、端口号</h3><pre><code>    类似pid标识一个进程：在网络程序中，用端口号（port）来标识一个运行的网络程序。    特点        1、端口号是无符号短整型的类型。        2、每个端口都拥有一个端口号。        3、TCP、UDP维护各自的端口号。        4、网络应用程序至少要占用一个端口号，也可以占用多个端口号。    知名端口（1-1023）    由互联网数字分配机构根据用户需求进行同意分配。    如：ftp --21，http----80等    服务器通常使用的范围；若强制使用，须加root特权    动态端口（1024 -65535）        应用程序通常使用的范围。        注意：端口号类似于进程号，同一时刻只能标记一个进程。            可以重复使用。</code></pre><p>​<img src="https://img-blog.csdnimg.cn/f971e73ae3c345f4a7fc4784f1ae99be.png"></p><h3 id="3-7-3、链路层封包格式"><a href="#3-7-3、链路层封包格式" class="headerlink" title="3-7-3、链路层封包格式"></a>3-7-3、链路层封包格式</h3><p><img src="https://img-blog.csdnimg.cn/24c0f30b07d94c0c930e06e7a9974f72.png"></p><pre><code>    目的地址：目的mac地址    源地址：源mac地址    类型：确实以太网后面跟的是那个协议，占两个字节    0x0800 ip协议（对应到网络层）    0x0806 arp协议    0x835 rarp协议</code></pre><p>注意：</p><pre><code>    1、IEEE802.2/802.3封装常用的无线    2、以太网封装常用在线局域网</code></pre><h3 id="3-7-4、网络层的数据报封装"><a href="#3-7-4、网络层的数据报封装" class="headerlink" title="3-7-4、网络层的数据报封装"></a>3-7-4、网络层的数据报封装</h3><p><img src="https://img-blog.csdnimg.cn/c80222851b674dd48cb6030addf7add0.png"></p><pre><code>    当协议改为6，或者17后，ip数据报后面紧跟的就是udp数据报或者tcp数据报。</code></pre><h2 id="3-8、c-x2F-s架构"><a href="#3-8、c-x2F-s架构" class="headerlink" title="3-8、c&#x2F;s架构"></a>3-8、c&#x2F;s架构</h2><pre><code>    无论是tcp还是udp，都是通过c/s架构运行的，client客户端，server服务器端。服务器是被动运行的，    客户端是主动运行的。</code></pre><p><img src="https://img-blog.csdnimg.cn/8d61b4162e4e4863b5554a968f4830f7.png"></p><pre><code>    server工作过程：    打开一通信通道并告知本地主机，它愿意在一特定端口（如80）上接收客户请求，    等待客户请求到达该端口，受客户请求，并发送应答信号，激活一新的线程处理客    户的这个请求，服务完成后，关闭新线程的客户的通信链路。    client工作过程    打开一通信通道并连接到服务器特定的端口，并向服务器发出服务请求，等待并接    收应答，根据需要继续提出请求，请求结束后关闭通信通道并终止。</code></pre><h1 id="4、字节序、地址转换"><a href="#4、字节序、地址转换" class="headerlink" title="4、字节序、地址转换"></a>4、字节序、地址转换</h1><pre><code>    多数据的存储顺序称之为字节序    分类：            大端格式：将高位字节数据存储低地址            小端格式：将低位字节数据存储在低地址    注意：        lsb：低地址        msb：高地址</code></pre><p><img src="https://img-blog.csdnimg.cn/e2ac1ef70b614bd49b8897f67cede098.png"></p><pre><code>    如何判断存储字节序</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union k&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union k j;</span><br><span class="line">j.a = 0x12345678;</span><br><span class="line">printf(&quot;j.b = %#x\r\n&quot;,j.b);</span><br><span class="line">if(j.b == 0x78)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;小端存储\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">j.b = 0x78</span><br><span class="line">小端存储</span><br></pre></td></tr></table></figure><pre><code>    一个地址位存储一个字节，一个字节8位。</code></pre><h2 id="4-1、字序转换"><a href="#4-1、字序转换" class="headerlink" title="4-1、字序转换"></a>4-1、字序转换</h2><pre><code>    特点：    1、协议指定了通讯字节序为大端存储。    2、只有在多字节数据处理的时候才需要考虑字节序。    3、运行在同一台计算机上的进程互相通讯时，一般不用考虑字节序。    4、异构计算机之间的通讯，需要转换自己的字节序为网络字节序。    在需要字节序转换的时候一般调用特定字节序转换函数。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">转化函数</span><br><span class="line">host ---&gt;networ  主机字节序转化为网络字节序</span><br><span class="line">1  ----htonl</span><br><span class="line">l将32位的转换，s将16位的转换。</span><br><span class="line">2 -----htons</span><br><span class="line"></span><br><span class="line">network ----&gt;host   网络字节序转化为主机字节序</span><br><span class="line">3 ----ntohl</span><br><span class="line"></span><br><span class="line">4 ----ntohs</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 0x12345678;</span><br><span class="line">short int b =0x1234;</span><br><span class="line">printf(&quot;%#x\n&quot;,htonl(a));</span><br><span class="line">printf(&quot;%#x\r\n&quot;,htons(b));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">0x78563412</span><br><span class="line">0x3412</span><br></pre></td></tr></table></figure><h2 id="4-2、地址转换"><a href="#4-2、地址转换" class="headerlink" title="4-2、地址转换"></a>4-2、地址转换</h2><pre><code>    ip地址人为识别的时候是字符串。    交给计算机识别时，要将它转化整型数据。    如192.168.3.104     交给计算机时，转化位四个字节的整型数据，以点好（.）为分割。</code></pre><h3 id="4-2-1、转换函数1"><a href="#4-2-1、转换函数1" class="headerlink" title="4-2-1、转换函数1"></a>4-2-1、转换函数1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inet_pton函数</span><br><span class="line"></span><br><span class="line">字符串ip转整型数据</span><br><span class="line"></span><br><span class="line">inet_ntop函数</span><br><span class="line">整型数据转字符串格式IP地址 </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">/****************将字符串地址转化为电脑能识别的无符号整形数据**********************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ip[] = &quot;192.168.3.103&quot;;</span><br><span class="line">unsigned int unip = 0;</span><br><span class="line">unsigned int *nip = NULL;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;unip);</span><br><span class="line">printf(&quot;%d\r\n&quot;,unip);/******       一个字节一个字节的取出，不然看不懂       *********/</span><br><span class="line">nip = &amp;unip;</span><br><span class="line">printf(&quot;unip = %d.%d.%d.%d\r\n&quot;,*(nip),*(nip+1),*(nip+2),*(nip+3));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/////////////////////////////////</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">///////////////////////////////////////</span><br><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">1728293056</span><br><span class="line">unip = 1728293056.-1553161620.32767.959575536</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char nip[] = &#123;192,168,3,103&#125;;</span><br><span class="line">    char ip[16];</span><br><span class="line">    inet_ntop(AF_INET,&amp;nip,ip,16);</span><br><span class="line">printf(&quot;%s\r\n&quot;,ip);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    结果</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">192.168.3.103</span><br></pre></td></tr></table></figure><h3 id="4-2-2、转换函数2"><a href="#4-2-2、转换函数2" class="headerlink" title="4-2-2、转换函数2"></a>4-2-2、转换函数2</h3><pre><code>    inet addr和inet_ntoa用的更多。只能用在ipv4上。比较重要</code></pre><h1 id="5、udp"><a href="#5、udp" class="headerlink" title="5、udp"></a>5、udp</h1><pre><code>    udp的应用：    dns域名解析，nfs网络文件系统，rtp流媒体</code></pre><h2 id="5-1、网络编程接口socket"><a href="#5-1、网络编程接口socket" class="headerlink" title="5-1、网络编程接口socket"></a>5-1、网络编程接口socket</h2><pre><code>    socket作用：        提供不同主机上的进程之间的通讯    socket 特点：            1、socket也称“套接字”。            2、是一种文件描述符，代表了一个个管道的端点。            3、类似对文件的操作一样，可以使用read、write、close等函数对socket套接            字进行网络数据的收取和发送等操作。            4、得到socket套接字（描述符）的方法调用socket    socket分类：            1、SOCK_STREAM,流式套接字，用于tcp            2、SOCK_DGRAM,数据报套接字，用于udp                        3、SOCK_RAW,原始套接字，对于其他层次的协议操作需要使用到这个类型</code></pre><p><img src="https://img-blog.csdnimg.cn/6edaf7ddf03a49a08e7fe92ac9e11a55.png"></p><pre><code>    编程流程：    一、服务器：    1、创建套接字socket                                                                 2、将服务器的ip地址、端口号与套接字进行绑定bind    3、接收数据recvfrom    4、发送数据sendto    二、客户端：    1、创建套接字socket    2、发送数据sendto    3、接收数据recvfrom    4、关闭套接字close    服务器创建套接字默认属性是主动的，就是当发起服务请求；当作为服务器时，往往需要改成被动的。</code></pre><h2 id="5-2、ipv4套接字的地址结构"><a href="#5-2、ipv4套接字的地址结构" class="headerlink" title="5-2、ipv4套接字的地址结构"></a>5-2、ipv4套接字的地址结构</h2><pre><code>    再网络编程中，为了使不同格式的地址能够被传入套接字函数，地址需要强制转换成通用套    接字地址结构，原因是因为不同的场合所使用的结构体不一样，但是调用的函数却是同一个，    所以定义一个通用的结构体，在指定场合使用时，再根据要求传入指定的结构体就行。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">头文件#include &lt;netinet/in.h&gt;</span><br><span class="line">struct in_addr</span><br><span class="line">&#123;</span><br><span class="line">in_addr_t s_addr; //ip地址，4个字节</span><br><span class="line">&#125;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">sa_famila_t sin_family ;//协议族2个字节</span><br><span class="line">in_port sin_port ;//端口号 2个字节</span><br><span class="line">struct in_addr sin_addr;//ip地址 4个字节</span><br><span class="line">char sin_zero[8];填充不起什么作用 8字节</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面这个是通用结构体</span><br><span class="line">struct sockaddr</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sa_family; //2字节</span><br><span class="line">char sa_data[14]//14字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    注意事项：    1、在定义源地址和目的地址结构的时候，选用struct  sockaddr_in。    如：struct sockaddr_in my_addr;    2、当调用编程接口函数，且该函数需要传入地址结构时需要用struct sockaddr进行强制转换。    如：bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(my_addr))</code></pre><h2 id="5-3、服务器向客户端发送数据"><a href="#5-3、服务器向客户端发送数据" class="headerlink" title="5-3、服务器向客户端发送数据"></a>5-3、服务器向客户端发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /******************  第二步 ：填充服务器网络信息结构体  sockaddr——in  *************/</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /************ ip地址转化为整形  ************/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4、绑定–bind函数"><a href="#5-4、绑定–bind函数" class="headerlink" title="5-4、绑定–bind函数"></a>5-4、绑定–bind函数</h2><pre><code>    由于服务器是被动的，客户端时主动的，客户端要找到服务器才能通讯，一般不    需要要bind绑定，只有服务器才需要bind绑定。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    给定的IP必须与服务器IP一致，不然就会发生报错。</code></pre><h2 id="5-5、接收数据-recvfrom"><a href="#5-5、接收数据-recvfrom" class="headerlink" title="5-5、接收数据-recvfrom"></a>5-5、接收数据-recvfrom</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd,void *buf,size_t nbytes,int flags, </span><br><span class="line">struct sockaddr* from,socklen_t *addrlen);</span><br><span class="line">功能：</span><br><span class="line">接收udp数据，并将源地址信息保存在from指向的结构体中。</span><br><span class="line">参数：</span><br><span class="line">sockfd：套接字。</span><br><span class="line">buf：接受数据的缓冲区。</span><br><span class="line">nbtyes：接收数据的缓冲区大小。</span><br><span class="line">flags：套接字标志（常为0）。</span><br><span class="line">from：源地址结构体指针，用来保存数据的来源。</span><br><span class="line">addrlen：from所指内容的场长度。</span><br><span class="line">注意：通过from和addrlen参数存放数据来源信息</span><br><span class="line">from和addrlen可以为NULL，表示不保存数据来源。</span><br><span class="line">返回值：</span><br><span class="line">成功返回：接收到的字节数。</span><br><span class="line">失败返回：-1。</span><br></pre></td></tr></table></figure><h2 id="5-6、客户端向服务器发送数据"><a href="#5-6、客户端向服务器发送数据" class="headerlink" title="5-6、客户端向服务器发送数据"></a>5-6、客户端向服务器发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 128</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************接收客户端发送的数据*********************/</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(recvfrom(sockfd,buf,N,0,(struct sockaddr *)&amp;clientaddr,&amp;addrlen) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;recvfrom_faile&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        /*******s_addr在计算机中是个32为的无符号的整数，需要转为点分十进制整数   inet_ntoa与其他转换函数不同，直接传结构体就可以*********/</span><br><span class="line">    printf(&quot;ip:%s  port:%d\r\n&quot;,inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));</span><br><span class="line">    printf(&quot;from client:%s\n&quot;,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-7、c-x2F-s架构"><a href="#5-7、c-x2F-s架构" class="headerlink" title="5-7、c&#x2F;s架构"></a>5-7、c&#x2F;s架构</h2><pre><code>在上面两个例子中发送数据的是client，接收数据的是server，其实在网络开发中，client和server都可以收发数据，只是一般认为吧提供服务的一方称为server，接受服务的一方称为client。</code></pre><h2 id="5-8、udp客户端注意点"><a href="#5-8、udp客户端注意点" class="headerlink" title="5-8、udp客户端注意点"></a>5-8、udp客户端注意点</h2><pre><code>1、本地ip、本地端口（我是谁）。2、目的ip、目的端口（发给谁）。3、在客户端的代码中、本地port是我们调用sendto的时候linux系统自动给客户端分配的，分配端口的方式为随机分配，即每次运行系统给的port不一样。客户端信息可以指定，也可以不指定，一般不需要。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /*****  第二步 ：填充服务器网络信息结构体  sockaddr——in  *******/</span><br><span class="line">/******一般不需要******/</span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /******** ip地址转化为整形  *********/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-9、服务器注意点"><a href="#5-9、服务器注意点" class="headerlink" title="5-9、服务器注意点"></a>5-9、服务器注意点</h2><pre><code>1、服务器之所以bind是因为它的本地port需要固定，不能是随机的。2、服务器也可以主动给客户端发送信息。3、客户端也可以使用bind绑定，这样客户端的本地端口就固定了，但是一般不这样做。</code></pre><h2 id="5-10、TFTP协议"><a href="#5-10、TFTP协议" class="headerlink" title="5-10、TFTP协议"></a>5-10、TFTP协议</h2><pre><code>    tftp：简单文本传送协议（传输小文件，基于udp）。    ftp：文件传输协议（传输大文件，基于tcp）。        数据传输模式：    octet：二进制模式。    netascii：文本模式。    tftp协议：端口号port 69。    </code></pre><p><img src="https://img-blog.csdnimg.cn/5e49086224114aefa92a77b2f1c7b0d8.png"></p><pre><code>tftp通讯总结：    1、服务器在69号端口等待客户端请求。    2、服务器若批准此请求，则使用临时端口与客户端进行通信。    3、每个数据包的编号都有变化（从1开始）。    4、每个数据包都要得到ACK的缺认，如果出现超时，则需要    重新发送最够的包（数据或者ACK）。    5、数据包的长度以521byte传输。    6、小于512byte的数据意味着传输结束。</code></pre><p><img src="https://img-blog.csdnimg.cn/067c7b99eed6491ca72d318ce376fac2.png"></p><pre><code>    以上的0代表的是‘\0’。不同的差错码对应不同的错误信息。</code></pre><p><img src="https://img-blog.csdnimg.cn/a298f86db91446cca4595708a9fb0ddb.png"></p><h2 id="5-11、使用TFTP下载"><a href="#5-11、使用TFTP下载" class="headerlink" title="5-11、使用TFTP下载"></a>5-11、使用TFTP下载</h2><pre><code>要求：使用tftp协议，下载server上的文件到本地。思路：    1、构造请求报文，发送到69端口。    2、等待服务器回应。    3、分析服务器回应。    4、接收数据，直到数据小于512字节。</code></pre><p><img src="https://img-blog.csdnimg.cn/2651a13cebea43b5824f7b569285a4fa.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  /**** printf ***/</span><br><span class="line">#include &lt;stdlib.h&gt; /**  exit  **/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt; /** socket **/</span><br><span class="line">#include &lt;sys/socket.h&gt; /**  sockaddr_in **/</span><br><span class="line">#include &lt;arpa/inet.h&gt; /** htons inet_addr **/</span><br><span class="line">#include &lt;unistd.h&gt; /** close**/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">void download(int sockfd,struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[128] = &quot;&quot;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名:\r\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,filename);</span><br><span class="line">    unsigned char text[1024] = &quot;&quot;;</span><br><span class="line">    int text_len;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num =0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    /********* 构建发给服务器的tftp指令，如：01test.txt0octet0 ***************/</span><br><span class="line">    text_len = sprintf(text,&quot;%c%c%s%c%s%c&quot;,0,1,filename,0,&quot;octet&quot;,0);//////////////////</span><br><span class="line">    if(sendto(sockfd,text,text_len,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to sendto&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /*** 接收服务器发来的信息并处理****/</span><br><span class="line">        bytes = recvfrom(sockfd,text,sizeof(text),0,(struct sockaddr *)&amp;serveraddr,&amp;addrlen);</span><br><span class="line">        if(bytes == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;recvfrom_filed&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /*** 判断操作码*****/</span><br><span class="line">        if(text[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;error:%s\n&quot;,text+4);</span><br><span class="line">        return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(text[1] == 3)</span><br><span class="line">       &#123;</span><br><span class="line">         &#123;</span><br><span class="line">            if(flags == 0)/*** 创建文件的，flags为标志位，防止重复创建***/</span><br><span class="line">            &#123;/**创建文件***/</span><br><span class="line">                if((fd = open(filename,O_WRONLY | O_CREAT | O_TRUNC,0664)) &lt; 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;failed_open&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flags = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        /**  对比块编号和接收的数据大小并将文件内容写入文件***/</span><br><span class="line">        if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes == 516))/** 接收到的数据包还要加上操作码和块编号，所以是516 ***/</span><br><span class="line">            &#123;</span><br><span class="line">                num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen))</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to send&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes &lt; 516))/**判断是否是最后一次传输**/</span><br><span class="line">            &#123; </span><br><span class="line">                 num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">                   &#123;</span><br><span class="line">                        perror(&quot;failed_sento&quot;);</span><br><span class="line">                        exit(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                printf(&quot;文件下载完成\r\n&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125; </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /** 创建套接字 **/</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sockfd_fail\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*** 填充服务器信息结构体 **/</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);/*** tftp服务器端地址 ***/</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line">   // if(bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof(serveraddr)) == -1)</span><br><span class="line">   // &#123;</span><br><span class="line">    //    perror(&quot;bind_fail\r\n&quot;);</span><br><span class="line">   //    exit(1);   </span><br><span class="line">   // &#125;</span><br><span class="line">    /*** 下载 ***/</span><br><span class="line">    download(sockfd,serveraddr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>以下是上传服务器的代码</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">上传服务器</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERRLOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line"></span><br><span class="line">void do_help()</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">    printf(&quot;------ 1. 下载 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 2. 上传 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 3. 退出 ------\n&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_download(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    char data[1024] = &quot;&quot;;</span><br><span class="line">    int data_len;</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int recv_len;</span><br><span class="line"></span><br><span class="line">    //组数据并发送</span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 1, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收数据并分析处理</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %u\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;error: %s\n&quot;, data + 4);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(data[1] == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            //防止文件内容清空</span><br><span class="line">            if(flags == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                flags = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断数据包的编号是否是上一次的编号加1</span><br><span class="line">            if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len == 516)</span><br><span class="line">            &#123;</span><br><span class="line">                //向文件写入数据</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">            </span><br><span class="line">                //组数据发送给服务器</span><br><span class="line">                data[1] = 4; </span><br><span class="line">                if(sendto(sockfd, data, 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                num = ntohs(*(unsigned short *)(data + 2));</span><br><span class="line">            &#125;</span><br><span class="line">            //接收到的最后一次的数据</span><br><span class="line">            else if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len &lt; 516)</span><br><span class="line">            &#123;</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件下载成功\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_upload(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要上传的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    //打开文件并判断文件是否存在</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(filename, O_RDONLY)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(errno == ENOENT)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;文件%s不存在，请重新输入\n&quot;, filename);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //组数据并发送给服务器执行上传功能</span><br><span class="line">    char data[1024] = &#123;&#125;;</span><br><span class="line">    int data_len;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 2, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line"></span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收服务器发送的数据并分析处理</span><br><span class="line">    int recv_len;</span><br><span class="line">    int num = 0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %d\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 4 &amp;&amp; num == ntohs(*(unsigned short *)(data + 2)))</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            bytes = read(fd, data + 4, 512);</span><br><span class="line">            data[1] = 3;</span><br><span class="line">            *(unsigned short *)(data + 2) = htons(num);</span><br><span class="line"></span><br><span class="line">            if(bytes == 512)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件上传完毕\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    //创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line"></span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;----请输入help查看帮助信息----\n&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;&gt;&gt;&gt; &quot;);</span><br><span class="line"></span><br><span class="line">    char buf[N] = &#123;&#125;;</span><br><span class="line">NEXT:</span><br><span class="line">    fgets(buf, N, stdin);</span><br><span class="line">    buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">    if(strncmp(buf, &quot;help&quot;, 4) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        do_help();</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">        goto NEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;input&gt;&gt;&gt; &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        switch (num)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            do_download(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            do_upload(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            close(sockfd);</span><br><span class="line">            exit(0);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、udp广播"><a href="#6、udp广播" class="headerlink" title="6、udp广播"></a>6、udp广播</h1><pre><code>    广播： 由一台主机向该主机所在子网内的所有主机发送数据的方式。    广播只能用 UDP 或原始 IP 实现， 不能用 TCP。        用途：    单个服务器与多个客户主机通信时减少分组流通。    以下几个协议都用到广播    1、 地址解析协议（ARP）。    2、 动态主机配置协议（DHCP）。    3、 网络时间协议（NTP）。    特点：        1、 处于同一子网的所有主机都必须处理数据。        2、 UDP 数据包会沿协议栈向上一直到 UDP 层。        3、 运行音视频等较高速率工作的应用， 会带来大负。        4、 局限于局域网内使用。    地址：    &#123;网络 ID， 主机 ID&#125;    网络 ID 表示由子网掩码中 1 覆盖的连续位。    主机 ID 表示由子网掩码中 0 覆盖的连续位。    定向广播地址： 主机 ID 全 1    1、 例： 对于 192.168.220.0/24，     其定向广播地址为 192.168.220.255。    2、 通常路由器不转发该广播    受限广播地址： 255.255.255.255，    路由器从不转发该广播。</code></pre><h2 id="6-1、单播"><a href="#6-1、单播" class="headerlink" title="6-1、单播"></a>6-1、单播</h2><p><img src="https://img-blog.csdnimg.cn/9c48ff8e0c7545f18f9a8ac94c1568aa.png"></p><h2 id="6-2、广播"><a href="#6-2、广播" class="headerlink" title="6-2、广播"></a>6-2、广播</h2><p><img src="https://img-blog.csdnimg.cn/0ab9e4650db64d47afc2c2fabf4e64e6.png"></p><h2 id="6-3、广播流程"><a href="#6-3、广播流程" class="headerlink" title="6-3、广播流程"></a>6-3、广播流程</h2><pre><code>    发送者：    第一步：创建套接字 socket()    第二步：设置为允许发送广播权限 setsockopt()    第三步：向广播地址发送数据 sendto()    接收者：    第一步：创建套接字 socket()    第二步：将套接字与广播的信息结构体绑定 bind()    第三步：接收数据 recvfrom()</code></pre><p><img src="https://img-blog.csdnimg.cn/3f72e370b170408ba1329af3e9fcbfe6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">套接字选项</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);</span><br><span class="line">功能：设置一个套接字的选项（属性）</span><br><span class="line"> 参数：</span><br><span class="line"> socket：文件描述符</span><br><span class="line"> level：协议层次</span><br><span class="line"> SOL_SOCKET 套接字层次</span><br><span class="line"> IPPROTO_TCP tcp层次</span><br><span class="line"> IPPROTO_IP IP层次</span><br><span class="line"> option_name：选项的名称</span><br><span class="line"> SO_BROADCAST 允许发送广播数据（SOL_SOCKET层次的）</span><br><span class="line"> option_value：设置的选项的值</span><br><span class="line"> int类型的值，存储的是bool的数据（1和0）</span><br><span class="line"> 0 不允许</span><br><span class="line"> 1 允许</span><br><span class="line">option_len：option_value的长度</span><br><span class="line"> 返回值：</span><br><span class="line">成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><h3 id="6-3-1、发送者"><a href="#6-3-1、发送者" class="headerlink" title="6-3-1、发送者"></a>6-3-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//广播发送者代码实现</span><br><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(sendaddr);</span><br><span class="line">    int on = 1;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET , SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**SOL_SOCKET：协议层次**/</span><br><span class="line">    /** SO_BROADCAST：允许发送广播权限**/</span><br><span class="line">    /**on：设置是否允许，设置为1表示允许，0表示不允许**/</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST,&amp;on,sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sersockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**绑定广播结构体**/    </span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /**进行通讯**/</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,sizeof(buf),stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;; /**将输入完的数据用 \0 结尾**/</span><br><span class="line">        if(sendto(sockfd, buf, sizeof(buf), 0,(struct sockaddr *)&amp;sendaddr, addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-2、接收者"><a href="#6-3-2、接收者" class="headerlink" title="6-3-2、接收者"></a>6-3-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in broadrecv;</span><br><span class="line">    socklen_t socklen;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /**填充信息结构体**/</span><br><span class="line">    broadrecv.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    broadrecv.sin_family = AF_INET;</span><br><span class="line">    broadrecv.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    /**将信息结构体与结构体绑定**/</span><br><span class="line">    socklen = sizeof(broadrecv);</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;broadrecv,socklen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;/**这里还要在申请的原因是要那来接受发送者的信息**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, buf, sizeof(buf), 0 ,(struct sockaddr *)&amp;sendaddr, &amp;socklen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">       //     exit(1);</span><br><span class="line">        &#125; </span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;, inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><pre><code>    接收者只能有一个，发送者可以有多个。</code></pre><h1 id="7、多播"><a href="#7、多播" class="headerlink" title="7、多播"></a>7、多播</h1><h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7-1、概念"></a>7-1、概念</h2><pre><code>数据的收发只在同一分组中进行。所以多播又称之为组播。多播的特点：    1、多播地址标示一组接口。    2、多播可以用于广域网使用。    3、在ipv4中，多播是可选的。    </code></pre><h2 id="7-1、多播地址"><a href="#7-1、多播地址" class="headerlink" title="7-1、多播地址"></a>7-1、多播地址</h2><pre><code>ipv4的D类地址是多播地址。多播地址向以太网mac地址的映射：</code></pre><p><img src="https://img-blog.csdnimg.cn/36714bc27d4f43a3873a84be62b12a47.png"></p><pre><code>    ipv4由32个字节构成，后23位组成以太网的都多播地址的底序23位，然后补一位0。    广播的发送者必须要设置允许发送广播，而多播必须加入多播组，才能接收到信息。</code></pre><p><img src="https://img-blog.csdnimg.cn/acd963041bbd47e88d005546c3bb7576.png"></p><pre><code>注意：mac地址后23位由ipv4的后23位构成，在接收者进行mac地址过滤的时候，进行的是不完全过滤，原因就在于23位前面有一位被指0，导致可能的错误，所以会在ipv4进行再次的过滤。比起广播，多播具有可控性，只有加入多播组的接收者才能接收数据。</code></pre><h2 id="7-2、多播的流程"><a href="#7-2、多播的流程" class="headerlink" title="7-2、多播的流程"></a>7-2、多播的流程</h2><pre><code>发送者：    第一步：创建套接字socket。    第二步：向多播地址发送数据sendto。接收者：    第一步：创建套接字socket。    第二步：设置为加入多播组setsockopt（）。    第三步：将套接字与多播信息结构体绑定。    第四步：接收数据。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多播地址结构体名字</span><br><span class="line">struct in_addr；</span><br><span class="line"></span><br><span class="line">struct ip_mreq;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/027660ee31f749ecbc7e1fd69de87a9b.png"><br><img src="https://img-blog.csdnimg.cn/451998d524cb4e27acd6698bc8308e64.png"></p><h3 id="7-2-1、发送者"><a href="#7-2-1、发送者" class="headerlink" title="7-2-1、发送者"></a>7-2-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using : %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**第一步，创建套接字**/</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    /********* ip地址必须设置为224.xxx.xxx.xxx 到239.... *********/</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    addrlen = sizeof(sendaddr);</span><br><span class="line">    /**发送数据**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, sizeof(buf),stdin);</span><br><span class="line">        buf[sizeof(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;sendaddr,addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-2、接收者"><a href="#7-2-2、接收者" class="headerlink" title="7-2-2、接收者"></a>7-2-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in recaddr;</span><br><span class="line">    </span><br><span class="line">    /***创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /***加入多播组**/</span><br><span class="line">    struct ip_mreq mreq;</span><br><span class="line">    mreq.imr_multiaddr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    /** INADDR_ANY表示任意主机**/</span><br><span class="line">    mreq.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    if(setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_setsockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    recaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    recaddr.sin_family = AF_INET;</span><br><span class="line">    recaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    addrlen = sizeof(recaddr);</span><br><span class="line">    /**绑定组播信息结构体**/</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;recaddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /** 进行通信***/</span><br><span class="line">    char text[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, text, sizeof(text), 0 , (struct sockaddr *)&amp;sendaddr,&amp;addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;,inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8、tcp"><a href="#8、tcp" class="headerlink" title="8、tcp"></a>8、tcp</h1><h2 id="8-1、tcp与udp对比"><a href="#8-1、tcp与udp对比" class="headerlink" title="8-1、tcp与udp对比"></a>8-1、tcp与udp对比</h2><p><img src="https://img-blog.csdnimg.cn/b48ee2f7f54843529407fba2c6ccdbc8.png"><br><img src="https://img-blog.csdnimg.cn/f8d0ff07fd604b44bd739194e6dffdc3.png"></p><h2 id="8-2、流程"><a href="#8-2、流程" class="headerlink" title="8-2、流程"></a>8-2、流程</h2><pre><code>服务器：    创建套接字socket（）。    将套接字与服务器网络信息结构体绑定。    将套接字设置为监听状态listen（）。    阻塞等待客户端的连接请求accept（）。    进行通信recv（）/send（）。    关闭套接字close（）。客户端：    创建套接字socket（）。    发送客户端连接请求connect（）。    进行通信send（）/recv（）。    关闭套接字close。    1、这里的socket的要使用的tcp的参数。2、connect作用是跟服务器建立连接，    连接成功后才可以进行tcp的数据传输。    连接成功后不会产生新的套接字。3、send函数，ssize_t send(int sockfd, const void *buf, size_t len, int flags);功能用于发送数据。    以下为各个函数的详细介绍：</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int socket(int domain, int type, int protocol);</span><br><span class="line"> 功能：创建一个套接字，返回一个文件描述符</span><br><span class="line"> 参数：</span><br><span class="line"> domain：通信域，协议族</span><br><span class="line"> AF_UNIX 本地通信</span><br><span class="line"> AF_INET ipv4网络协议</span><br><span class="line"> AF_INET6 ipv6网络协议</span><br><span class="line"> AF_PACKET 底层接口</span><br><span class="line"> type：套接字的类型</span><br><span class="line"> SOCK_STREAM 流式套接字（tcp）</span><br><span class="line"> SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line"> SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line"> protocol：附加协议，如果不需要，则设置为0</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：文件描述符</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connect函数：</span><br><span class="line">#include &lt;sys/types.h&gt; </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：给服务器发送客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket函数的返回值</span><br><span class="line">addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line">addrlen：add的长度</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"> 功能：发送数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：发送的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure><pre><code>    注意：不能用tcp协议发送0长度的数据包。    </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"> 功能：接收数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：保存接收到的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line">成功：接收的字节数</span><br><span class="line"> 失败：‐1</span><br><span class="line"> 如果发送端关闭文件描述符或者关闭进程，则recv函数会返回0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {        background: transparent !important;      }      #page-header {        background: transparent !important;      }            /* 白天模式遮罩透明 */      #footer::before {        background: transparent !important;      }      #page-header::before {        background: transparent !important;      }          /* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {        background: #1e1e1e;        color: antiquewhite;      }      /* 鼠标悬浮状态 */      [data-theme="dark"] .magnet_link_context:hover {        background: #3ecdf1;        color: #f2f2f2;      }      /* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 背景宇宙星光  */#universe{        display: block;        position: fixed;        margin: 0;        padding: 0;        border: 0;        outline: 0;        left: 0;        top: 0;        width: 100%;        height: 100%;        pointer-events: none;        /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */        z-index: -1;      }      @font-face {        /* 为载入的字体取名字(随意) */        font-family: 'YSHST';        /* 字体文件地址(相对或者绝对路径都可以) */        src: url(/font/方正楷体简体.woff2);        /* 定义加粗样式(加粗多少) */        font-weight: normal;        /* 定义字体样式(斜体/非斜体) */        font-style: normal;        /* 定义显示样式 */        font-display: block;      }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
  
</search>
