<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>网络 | wesker-yanggc</title><meta name="author" content="wesker-yanggc,862450734@qq.com"><meta name="copyright" content="wesker-yanggc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="referrer" content="no-referrer"><meta name="description" content="计算机网络笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="网络">
<meta property="og:url" content="https://wesker-blog.github.io/posts/50daec4.html">
<meta property="og:site_name" content="wesker-yanggc">
<meta property="og:description" content="计算机网络笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2d150d9eaa2144b1b4746590c5253c6b.png">
<meta property="article:published_time" content="2023-02-25T05:33:34.952Z">
<meta property="article:modified_time" content="2023-03-14T10:04:06.976Z">
<meta property="article:author" content="wesker-yanggc">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2d150d9eaa2144b1b4746590c5253c6b.png"><link rel="shortcut icon" href="https://img-blog.csdnimg.cn/3f85d3c8bd46405ab95747f19fcc1576.jpeg"><link rel="canonical" href="https://wesker-blog.github.io/posts/50daec4.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-14 18:04:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3f85d3c8bd46405ab95747f19fcc1576.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img-blog.csdnimg.cn/2d150d9eaa2144b1b4746590c5253c6b.png')"><nav id="nav"><span id="blog-info"><a href="/" title="wesker-yanggc"><span class="site-name">wesker-yanggc</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-25T05:33:34.952Z" title="发表于 2023-02-25 13:33:34">2023-02-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-14T10:04:06.976Z" title="更新于 2023-03-14 18:04:06">2023-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux%E5%BC%80%E5%8F%91/">Linux开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1、计算机网络发展"><a href="#1、计算机网络发展" class="headerlink" title="1、计算机网络发展"></a>1、计算机网络发展</h1><pre><code>    最早的计算机网络是ARPA，但是最早的ARPA无法连接不同类型的计算机和不同的操作系统。
</code></pre>
<h2 id="1-1、数据交换"><a href="#1-1、数据交换" class="headerlink" title="1-1、数据交换"></a>1-1、数据交换</h2><pre><code>    通过标有地址的分组进行路由选择传输数据，使得通信通道仅在传送期间被占用的一种交换方式。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/5cd87be15c474bb4a11ea5605aacba60.png"></p>
<h2 id="1-2、交换方式"><a href="#1-2、交换方式" class="headerlink" title="1-2、交换方式"></a>1-2、交换方式</h2><pre><code>    交换的方式为存储转发，节点收到分组，先暂时存储下来，再检查它的头部，然后按照首部中的地址，
    找到合适的节点转发出去。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/38f63356e5bd4db8bc28ae74904b60b8.png"></p>
<h3 id="1-2-3、特点"><a href="#1-2-3、特点" class="headerlink" title="1-2-3、特点"></a>1-2-3、特点</h3><pre><code>    1、以分组作为传输单位。

    2、独立选择转发路由。

    3、逐段占用，动态分配传输带宽。
</code></pre>
<h2 id="1-3、发展过程"><a href="#1-3、发展过程" class="headerlink" title="1-3、发展过程"></a>1-3、发展过程</h2><pre><code>    从单个ARPA发展为tcp/ip的ARPAnei的标注协议。
</code></pre>
<h1 id="2、英特网的结构"><a href="#2、英特网的结构" class="headerlink" title="2、英特网的结构"></a>2、英特网的结构</h1><h2 id="2-1、三级结构英特网"><a href="#2-1、三级结构英特网" class="headerlink" title="2-1、三级结构英特网"></a>2-1、三级结构英特网</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f7f7b18bdcc34f3da0c9c8a8cb7bf3c5.png"></p>
<pre><code>    每个国家都有一个主干网，然后层级下发。
</code></pre>
<h2 id="2-2、多级英特网"><a href="#2-2、多级英特网" class="headerlink" title="2-2、多级英特网"></a>2-2、多级英特网</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/cbcbf5759d5b4650927a741f82519b69.png"></p>
<h1 id="3、TCP-x2F-IP协议族"><a href="#3、TCP-x2F-IP协议族" class="headerlink" title="3、TCP&#x2F;IP协议族"></a>3、TCP&#x2F;IP协议族</h1><h2 id="3-1、分层结构"><a href="#3-1、分层结构" class="headerlink" title="3-1、分层结构"></a>3-1、分层结构</h2><pre><code>    由来：主要是为了解决不同计算机之间和不同操作系统直接的差异，就进行分层，只需要保证某些层次是一样的，
    就可以进行通讯。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ef551d0f79a44d0282306cd494cad2d2.png"></p>
<pre><code>    最造的分层体系是osi开放系统互联模型，是由国际化标准组织（iso）指定，由于osi过于
    复杂，所以到现在也没有使用，而是使用的是TCP/IP协议族。

    应用层：应用程序沟通的 例如：FTP、HTTP、Telnet等。

    FTP：文件传输协议，如app的上传和下载功能。

    HTTP：超文本协议，通过浏览器访问其他网站，必须通过http协议。

    传输层：提供程序间数据的传输逻辑通讯，例如TCP、UDP。

    网络层：提供基本的数据包传送功能，最大可能的能让每个数据报都能到达主机，例如IP、ICMP等。

    IP：用来找到目的主机。

    链路层：负责数据帧的发送和接收。一个数据称为一帧数据。

    每层完成自己的任务，最终完成不同层次的处理完成数据的收发。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/ca77435a4b2149d89386f95c286a87b2.png"></p>
<pre><code>    上图的ARP协议是通过对方的ip地址找对方MAC地址，而RARP则是通过MAC地址找ip地址。

    数据是从应用层到传输层，一直到链路层，整体把数据交给链路层之后，将数据传给对方，然后最后层
    层解封。
</code></pre>
<h2 id="3-2、-IP协议"><a href="#3-2、-IP协议" class="headerlink" title="3-2、 IP协议"></a>3-2、 IP协议</h2><pre><code>    特指为实现一个相互连接的网络系统上从源地址到目的地传输数据包所提供的必要协议。也称为网际协议。

特点：	不可靠：他不能保证ip数据包能够成功的到达它的目的地，只能尽力而为的传输服务。
        无连接：ip并不维护后数据包的状态信息。每个数据包是相互独立的。ip数据包可以不安发送数据发送。

        ​ip数据包中有它的发送地址ip和接收它的ip主机地址。
</code></pre>
<h2 id="3-3、tcp协议简介"><a href="#3-3、tcp协议简介" class="headerlink" title="3-3、tcp协议简介"></a>3-3、tcp协议简介</h2><pre><code>    tcp协议是面向连接的，可靠的传输层通讯协议。

        功能：提供不同主机上的进程间通讯。

    特点：
        1、建立链接-&gt;使用链接-&gt;释放链接（虚电路）。
        2、tcp数据包中包含序号和确认序号。
        3、对包经行排序并检错，而损坏的包可以被重传。

    服务对象
        需要高度可靠并面向连接的服务。
                如：http、ftp、smtp等。
                smtp为简单邮件传输协议。
</code></pre>
<h2 id="3-4、udp协议简介"><a href="#3-4、udp协议简介" class="headerlink" title="3-4、udp协议简介"></a>3-4、udp协议简介</h2><pre><code>    udp是一种面向无连接的传输层通讯协议。也称用户数据报协议。

    功能：
            提供不同主机上的进程间通讯。

    特点：
        1、发送数据前不需要建立链接。
        2、不对数据包的顺序进行检查。
        3、没有错误检测和重传机制。

    服务对象：
    主要用于查询应答服务。
    如：nfs、ntp、dns等
</code></pre>
<h2 id="3-5、mac地址"><a href="#3-5、mac地址" class="headerlink" title="3-5、mac地址"></a>3-5、mac地址</h2><pre><code>    mac地址类似于身份证号。出场的时候标出，理论上全球唯一。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/1941966561584d70ae12c4c6b66bb977.png"></p>
<pre><code>    组成：以太网内的MAC地址是一个48bit的值。mac地址是可以修改的，但是一般情况下不建议修改mac地址。

    总共分成6组，通过 : 隔开，前三组称为厂商ID，后三组称为设备ID。

    如果是我们自己识别的话是分组识别，如果是输入给计算机的话就是48位的值。
</code></pre>
<h2 id="3-6、ip地址"><a href="#3-6、ip地址" class="headerlink" title="3-6、ip地址"></a>3-6、ip地址</h2><pre><code>    ip地址是一种internet上的主机编址，也称为网际协议地址。

    ip地址在网络中具有唯一标识。
</code></pre>
<h3 id="3-6-1、IP地址的分类"><a href="#3-6-1、IP地址的分类" class="headerlink" title="3-6-1、IP地址的分类"></a>3-6-1、IP地址的分类</h3><pre><code>    ipv4，占32位

    ipv6，占128位
</code></pre>
<h4 id="3-6-1-1、ipv4组成"><a href="#3-6-1-1、ipv4组成" class="headerlink" title="3-6-1-1、ipv4组成"></a>3-6-1-1、ipv4组成</h4><pre><code>    ipv4一般使用点分十进制字符串来标识，如192.168.1.135。
</code></pre>
<h3 id="3-6-2、ip组成"><a href="#3-6-2、ip组成" class="headerlink" title="3-6-2、ip组成"></a>3-6-2、ip组成</h3><pre><code>    使用32位，有&#123;网络id，主机id&#125;两部分组成

    子网：IP地址中由1覆盖的连续位

    主机：由ip地址中0覆盖的连续位
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/5ad8577b9e6840d9b84fe228898a2c5a.png"></p>
<pre><code>    子网ID不同的网络不能直接通讯，如果要通讯要通过路由器转发。

    主机id全为0表示网段地址。

    主机id全为1的ip地址表示该网段的广播地址。

    如192.168.1.0为表示网段，192.168.1.255为广播地址。
</code></pre>
<h3 id="3-6-3、ipv4的地址分类（依据前8位进行区分）"><a href="#3-6-3、ipv4的地址分类（依据前8位进行区分）" class="headerlink" title="3-6-3、ipv4的地址分类（依据前8位进行区分）"></a>3-6-3、ipv4的地址分类（依据前8位进行区分）</h3><pre><code>    A类地址：默认8位子网id，第一位为0，前8位00000000 - 0111 1111，
    范围0.x.x.x - 127.x.x.x

    B类地址：默认16位子网id，前两位为10，前8位1000 0000  -  1011 1111，
    范围128.x.x.x  -  191.x.x.x

    C类地址：默认24位子网id，前三位为110，前8位为1100 0000   -  1101 1111 ，
    范围192 .x.x.x  -  223.x.x.x

    D类地址：前四位为1110，多播地址，前8位1110 0000 -  1110 1111，
    范围224.x.x.x  -  239.x.x.x

    E类地址：前五位为1111 0，保留为今后使用，前八位为1111 0000  -  1111 1111 ，
    范围240 .x.x.x -  255.x.x.x
</code></pre>
<h3 id="3-6-4、私有ip"><a href="#3-6-4、私有ip" class="headerlink" title="3-6-4、私有ip"></a>3-6-4、私有ip</h3><pre><code>    公有ip(可直接联网)：
        经由internic同意规划的ip

    私有ip（不可直接连接internet）：
        主要用于局域网络内的主机联机规划		
</code></pre>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c762dbe1e3404ba29225baaf2ec4e34e.png"></p>
<h3 id="3-6-5、回环ip地址"><a href="#3-6-5、回环ip地址" class="headerlink" title="3-6-5、回环ip地址"></a>3-6-5、回环ip地址</h3><pre><code>    通常127.0.0.1称为回环地址

    功能：
    主要是测试本机的网络配置，能ping通127.0.0.1说明本机的网卡和ip协议的安装没有问题。

    注意：
    127.0.0.1----127.255.255.254中的任何地址都将回环到本机的地址中，不属于任何一个有类别的地址类，
    它代表着设备的本地接口。
</code></pre>
<h3 id="3-6-6、子网掩码"><a href="#3-6-6、子网掩码" class="headerlink" title="3-6-6、子网掩码"></a>3-6-6、子网掩码</h3><p>子网掩码又称为网络掩码、地址掩码是一个有32位由1和0组成的数值，并且1和0分别连续。</p>
<p>作用：</p>
<p>​		用于指明ip地址中那些是子网，那些是主机号。</p>
<p>特点：</p>
<p>​		必须结合ip地址一起使用，不能单独存在。</p>
<p>​		ip地址中由子网掩码中1覆盖的连续位为子网id，其余为主机id。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c67cd045ae8f421ba831a9973d9f5065.png"></p>
<h2 id="3-7、端口"><a href="#3-7、端口" class="headerlink" title="3-7、端口"></a>3-7、端口</h2><h3 id="3-7-1、端口概述"><a href="#3-7-1、端口概述" class="headerlink" title="3-7-1、端口概述"></a>3-7-1、端口概述</h3><pre><code>    tcp/ip采用端口标识通信进程，用于区分一个系统里的多个进程。

    特点：
    1、对于同一个端口，在不同的系统中对应着不同的进程。
    2、对于同一个系统，一个端口只能被一个进程拥有。
    3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，
    进程送交传输层的数据也通过该端口被送出。
</code></pre>
<h3 id="3-7-2、端口号"><a href="#3-7-2、端口号" class="headerlink" title="3-7-2、端口号"></a>3-7-2、端口号</h3><pre><code>    类似pid标识一个进程：在网络程序中，用端口号（port）来标识一个运行的网络程序。

    特点
        1、端口号是无符号短整型的类型。
        2、每个端口都拥有一个端口号。
        3、TCP、UDP维护各自的端口号。
        4、网络应用程序至少要占用一个端口号，也可以占用多个端口号。

    知名端口（1-1023）
    由互联网数字分配机构根据用户需求进行同意分配。
    如：ftp --21，http----80等
    服务器通常使用的范围；若强制使用，须加root特权

    动态端口（1024 -65535）
        应用程序通常使用的范围。
        注意：端口号类似于进程号，同一时刻只能标记一个进程。
            可以重复使用。
</code></pre>
<p>​	<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f971e73ae3c345f4a7fc4784f1ae99be.png"></p>
<h3 id="3-7-3、链路层封包格式"><a href="#3-7-3、链路层封包格式" class="headerlink" title="3-7-3、链路层封包格式"></a>3-7-3、链路层封包格式</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/24c0f30b07d94c0c930e06e7a9974f72.png"></p>
<pre><code>    目的地址：目的mac地址

    源地址：源mac地址

    类型：确实以太网后面跟的是那个协议，占两个字节
    0x0800 ip协议（对应到网络层）
    0x0806 arp协议
    0x835 rarp协议
</code></pre>
<p>注意：</p>
<pre><code>    1、IEEE802.2/802.3封装常用的无线

    2、以太网封装常用在线局域网
</code></pre>
<h3 id="3-7-4、网络层的数据报封装"><a href="#3-7-4、网络层的数据报封装" class="headerlink" title="3-7-4、网络层的数据报封装"></a>3-7-4、网络层的数据报封装</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/c80222851b674dd48cb6030addf7add0.png"></p>
<pre><code>    当协议改为6，或者17后，ip数据报后面紧跟的就是udp数据报或者tcp数据报。
</code></pre>
<h2 id="3-8、c-x2F-s架构"><a href="#3-8、c-x2F-s架构" class="headerlink" title="3-8、c&#x2F;s架构"></a>3-8、c&#x2F;s架构</h2><pre><code>    无论是tcp还是udp，都是通过c/s架构运行的，client客户端，server服务器端。服务器是被动运行的，
    客户端是主动运行的。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8d61b4162e4e4863b5554a968f4830f7.png"></p>
<pre><code>    server工作过程：
    打开一通信通道并告知本地主机，它愿意在一特定端口（如80）上接收客户请求，
    等待客户请求到达该端口，受客户请求，并发送应答信号，激活一新的线程处理客
    户的这个请求，服务完成后，关闭新线程的客户的通信链路。

    client工作过程
    打开一通信通道并连接到服务器特定的端口，并向服务器发出服务请求，等待并接
    收应答，根据需要继续提出请求，请求结束后关闭通信通道并终止。
</code></pre>
<h1 id="4、字节序、地址转换"><a href="#4、字节序、地址转换" class="headerlink" title="4、字节序、地址转换"></a>4、字节序、地址转换</h1><pre><code>    多数据的存储顺序称之为字节序

    分类：
            大端格式：将高位字节数据存储低地址
            小端格式：将低位字节数据存储在低地址

    注意：
        lsb：低地址
        msb：高地址
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/e2ac1ef70b614bd49b8897f67cede098.png"></p>
<pre><code>    如何判断存储字节序
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">union k&#123;</span><br><span class="line">int a;</span><br><span class="line">char b;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">union k j;</span><br><span class="line">j.a = 0x12345678;</span><br><span class="line">printf(&quot;j.b = %#x\r\n&quot;,j.b);</span><br><span class="line">if(j.b == 0x78)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;小端存储\r\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">j.b = 0x78</span><br><span class="line">小端存储</span><br></pre></td></tr></table></figure>

<pre><code>    一个地址位存储一个字节，一个字节8位。
</code></pre>
<h2 id="4-1、字序转换"><a href="#4-1、字序转换" class="headerlink" title="4-1、字序转换"></a>4-1、字序转换</h2><pre><code>    特点：

    1、协议指定了通讯字节序为大端存储。

    2、只有在多字节数据处理的时候才需要考虑字节序。

    3、运行在同一台计算机上的进程互相通讯时，一般不用考虑字节序。

    4、异构计算机之间的通讯，需要转换自己的字节序为网络字节序。

    在需要字节序转换的时候一般调用特定字节序转换函数。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">转化函数</span><br><span class="line">host ---&gt;networ  主机字节序转化为网络字节序</span><br><span class="line">1  ----htonl</span><br><span class="line">l将32位的转换，s将16位的转换。</span><br><span class="line">2 -----htons</span><br><span class="line"></span><br><span class="line">network ----&gt;host   网络字节序转化为主机字节序</span><br><span class="line">3 ----ntohl</span><br><span class="line"></span><br><span class="line">4 ----ntohs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 0x12345678;</span><br><span class="line">short int b =0x1234;</span><br><span class="line">printf(&quot;%#x\n&quot;,htonl(a));</span><br><span class="line">printf(&quot;%#x\r\n&quot;,htons(b));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~$ ./a.out </span><br><span class="line">0x78563412</span><br><span class="line">0x3412</span><br></pre></td></tr></table></figure>

<h2 id="4-2、地址转换"><a href="#4-2、地址转换" class="headerlink" title="4-2、地址转换"></a>4-2、地址转换</h2><pre><code>    ip地址人为识别的时候是字符串。

    交给计算机识别时，要将它转化整型数据。
    如192.168.3.104 

    交给计算机时，转化位四个字节的整型数据，以点好（.）为分割。
</code></pre>
<h3 id="4-2-1、转换函数1"><a href="#4-2-1、转换函数1" class="headerlink" title="4-2-1、转换函数1"></a>4-2-1、转换函数1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inet_pton函数</span><br><span class="line"></span><br><span class="line">字符串ip转整型数据</span><br><span class="line"></span><br><span class="line">inet_ntop函数</span><br><span class="line">整型数据转字符串格式IP地址 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">/****************将字符串地址转化为电脑能识别的无符号整形数据**********************/</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">char ip[] = &quot;192.168.3.103&quot;;</span><br><span class="line">unsigned int unip = 0;</span><br><span class="line">unsigned int *nip = NULL;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;unip);</span><br><span class="line">printf(&quot;%d\r\n&quot;,unip);/******       一个字节一个字节的取出，不然看不懂       *********/</span><br><span class="line">nip = &amp;unip;</span><br><span class="line">printf(&quot;unip = %d.%d.%d.%d\r\n&quot;,*(nip),*(nip+1),*(nip+2),*(nip+3));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">/////////////////////////////////</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">///////////////////////////////////////</span><br><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">1728293056</span><br><span class="line">unip = 1728293056.-1553161620.32767.959575536</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char nip[] = &#123;192,168,3,103&#125;;</span><br><span class="line">    char ip[16];</span><br><span class="line">    inet_ntop(AF_INET,&amp;nip,ip,16);</span><br><span class="line">printf(&quot;%s\r\n&quot;,ip);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    结果
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ygc@ygc:~/network$ ./a.out </span><br><span class="line">192.168.3.103</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2、转换函数2"><a href="#4-2-2、转换函数2" class="headerlink" title="4-2-2、转换函数2"></a>4-2-2、转换函数2</h3><pre><code>    inet addr和inet_ntoa用的更多。只能用在ipv4上。比较重要
</code></pre>
<h1 id="5、udp"><a href="#5、udp" class="headerlink" title="5、udp"></a>5、udp</h1><pre><code>    udp的应用：

    dns域名解析，nfs网络文件系统，rtp流媒体
</code></pre>
<h2 id="5-1、网络编程接口socket"><a href="#5-1、网络编程接口socket" class="headerlink" title="5-1、网络编程接口socket"></a>5-1、网络编程接口socket</h2><pre><code>    socket作用：

        提供不同主机上的进程之间的通讯

    socket 特点：

            1、socket也称“套接字”。

            2、是一种文件描述符，代表了一个个管道的端点。

            3、类似对文件的操作一样，可以使用read、write、close等函数对socket套接
            字进行网络数据的收取和发送等操作。

            4、得到socket套接字（描述符）的方法调用socket

    socket分类：

            1、SOCK_STREAM,流式套接字，用于tcp

            2、SOCK_DGRAM,数据报套接字，用于udp
            
            3、SOCK_RAW,原始套接字，对于其他层次的协议操作需要使用到这个类型
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/6edaf7ddf03a49a08e7fe92ac9e11a55.png"></p>
<pre><code>    编程流程：

    一、	服务器：
    1、创建套接字socket                                                             
    2、将服务器的ip地址、端口号与套接字进行绑定bind
    3、接收数据recvfrom
    4、发送数据sendto

    二、	客户端：

    1、创建套接字socket
    2、发送数据sendto
    3、	接收数据recvfrom
    4、	关闭套接字close

    服务器创建套接字默认属性是主动的，就是当发起服务请求；当作为服务器时，往往需要改成被动的。
</code></pre>
<h2 id="5-2、ipv4套接字的地址结构"><a href="#5-2、ipv4套接字的地址结构" class="headerlink" title="5-2、ipv4套接字的地址结构"></a>5-2、ipv4套接字的地址结构</h2><pre><code>    再网络编程中，为了使不同格式的地址能够被传入套接字函数，地址需要强制转换成通用套
    接字地址结构，原因是因为不同的场合所使用的结构体不一样，但是调用的函数却是同一个，
    所以定义一个通用的结构体，在指定场合使用时，再根据要求传入指定的结构体就行。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">头文件#include &lt;netinet/in.h&gt;</span><br><span class="line">struct in_addr</span><br><span class="line">&#123;</span><br><span class="line">in_addr_t s_addr; //ip地址，4个字节</span><br><span class="line">&#125;</span><br><span class="line">struct sockaddr_in</span><br><span class="line">&#123;</span><br><span class="line">sa_famila_t sin_family ;//协议族2个字节</span><br><span class="line">in_port sin_port ;//端口号 2个字节</span><br><span class="line">struct in_addr sin_addr;//ip地址 4个字节</span><br><span class="line">char sin_zero[8];填充不起什么作用 8字节</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面这个是通用结构体</span><br><span class="line">struct sockaddr</span><br><span class="line">&#123;</span><br><span class="line">sa_family_t sa_family; //2字节</span><br><span class="line">char sa_data[14]//14字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    注意事项：

    1、在定义源地址和目的地址结构的时候，选用struct  sockaddr_in。
    如：struct sockaddr_in my_addr;

    2、当调用编程接口函数，且该函数需要传入地址结构时需要用struct sockaddr进行强制转换。
    如：bind(sockfd,(struct sockaddr *)&amp;my_addr,sizeof(my_addr))
</code></pre>
<h2 id="5-3、服务器向客户端发送数据"><a href="#5-3、服务器向客户端发送数据" class="headerlink" title="5-3、服务器向客户端发送数据"></a>5-3、服务器向客户端发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /******************  第二步 ：填充服务器网络信息结构体  sockaddr——in  *************/</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /************ ip地址转化为整形  ************/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4、绑定–bind函数"><a href="#5-4、绑定–bind函数" class="headerlink" title="5-4、绑定–bind函数"></a>5-4、绑定–bind函数</h2><pre><code>    由于服务器是被动的，客户端时主动的，客户端要找到服务器才能通讯，一般不
    需要要bind绑定，只有服务器才需要bind绑定。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    给定的IP必须与服务器IP一致，不然就会发生报错。
</code></pre>
<h2 id="5-5、接收数据-recvfrom"><a href="#5-5、接收数据-recvfrom" class="headerlink" title="5-5、接收数据-recvfrom"></a>5-5、接收数据-recvfrom</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ssize_t recvfrom(int sockfd,void *buf,size_t nbytes,int flags, </span><br><span class="line">struct sockaddr* from,socklen_t *addrlen);</span><br><span class="line">功能：</span><br><span class="line">接收udp数据，并将源地址信息保存在from指向的结构体中。</span><br><span class="line">参数：</span><br><span class="line">	sockfd：套接字。</span><br><span class="line">	buf：接受数据的缓冲区。</span><br><span class="line">	nbtyes：接收数据的缓冲区大小。</span><br><span class="line">	flags：套接字标志（常为0）。</span><br><span class="line">	from：源地址结构体指针，用来保存数据的来源。</span><br><span class="line">	addrlen：from所指内容的场长度。</span><br><span class="line">	注意：通过from和addrlen参数存放数据来源信息</span><br><span class="line">			from和addrlen可以为NULL，表示不保存数据来源。</span><br><span class="line">	返回值：</span><br><span class="line">	成功返回：接收到的字节数。</span><br><span class="line">	失败返回：-1。</span><br></pre></td></tr></table></figure>
<h2 id="5-6、客户端向服务器发送数据"><a href="#5-6、客户端向服务器发送数据" class="headerlink" title="5-6、客户端向服务器发送数据"></a>5-6、客户端向服务器发送数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N 128</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;usage: %s ip port\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*******创建套接字*******/</span><br><span class="line">    int sockfd;</span><br><span class="line">    if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************将服务器的网络信息结构体进行绑定******************/</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /********将网络信息结构体与网络套接字绑定************/</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind failed\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*************接收客户端发送的数据*********************/</span><br><span class="line">    char buf[N] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">    if(recvfrom(sockfd,buf,N,0,(struct sockaddr *)&amp;clientaddr,&amp;addrlen) == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;recvfrom_faile&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        /*******s_addr在计算机中是个32为的无符号的整数，需要转为点分十进制整数   inet_ntoa与其他转换函数不同，直接传结构体就可以*********/</span><br><span class="line">    printf(&quot;ip:%s  port:%d\r\n&quot;,inet_ntoa(clientaddr.sin_addr),ntohs(clientaddr.sin_port));</span><br><span class="line">    printf(&quot;from client:%s\n&quot;,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-7、c-x2F-s架构"><a href="#5-7、c-x2F-s架构" class="headerlink" title="5-7、c&#x2F;s架构"></a>5-7、c&#x2F;s架构</h2><pre><code>在上面两个例子中发送数据的是client，接收数据的是server，
其实在网络开发中，client和server都可以收发数据，只是一
般认为吧提供服务的一方称为server，接受服务的一方称为client。
</code></pre>
<h2 id="5-8、udp客户端注意点"><a href="#5-8、udp客户端注意点" class="headerlink" title="5-8、udp客户端注意点"></a>5-8、udp客户端注意点</h2><pre><code>1、本地ip、本地端口（我是谁）。
2、目的ip、目的端口（发给谁）。
3、在客户端的代码中、本地port是我们调用sendto的时候linux
系统自动给客户端分配的，分配端口的方式为随机分配，即
每次运行系统给的port不一样。
客户端信息可以指定，也可以不指定，一般不需要。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //</span><br><span class="line">#include &lt;netinet/in.h&gt;  //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt;  //htons iner_addr</span><br><span class="line">#include &lt;unistd.h&gt;  //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define N   8</span><br><span class="line">int main(int argc,char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    /********** 用socket创建 ***************/</span><br><span class="line">    /******* AF_INET 作用是使用ipv4的地址 *****/</span><br><span class="line">/**************  SOCK_DGRAM 数据报套接字 ********************/</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)  </span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;fail to socket\r\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;socket = %d\r\n&quot;,sockfd);</span><br><span class="line">  /*****  第二步 ：填充服务器网络信息结构体  sockaddr——in  *******/</span><br><span class="line">/******一般不需要******/</span><br><span class="line">  struct sockaddr_in serveraddr;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">     serveraddr.sin_addr.s_addr = inet_addr(&quot;192.168.1.135&quot;); /******** ip地址转化为整形  *********/</span><br><span class="line">      serveraddr.sin_port = htons(8080);</span><br><span class="line">        /**********  第三步 发送数据 *************/</span><br><span class="line">        char buf[N] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,N,stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd, buf, N,0,(struct sockaddr *)&amp;serveraddr,addrlen) == -1)</span><br><span class="line">        &#123;</span><br><span class="line">           perror(&quot;send_fail\r\n&quot;);</span><br><span class="line">           exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;send_ok\r\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-9、服务器注意点"><a href="#5-9、服务器注意点" class="headerlink" title="5-9、服务器注意点"></a>5-9、服务器注意点</h2><pre><code>1、服务器之所以bind是因为它的本地port需要固定，不能是随机的。
2、服务器也可以主动给客户端发送信息。
3、客户端也可以使用bind绑定，这样客户端的本地端口就固定了，
但是一般不这样做。
</code></pre>
<h2 id="5-10、TFTP协议"><a href="#5-10、TFTP协议" class="headerlink" title="5-10、TFTP协议"></a>5-10、TFTP协议</h2><pre><code>    tftp：简单文本传送协议（传输小文件，基于udp）。
    ftp：文件传输协议（传输大文件，基于tcp）。
    
    数据传输模式：
    octet：二进制模式。
    netascii：文本模式。
    tftp协议：端口号port 69。
    
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/5e49086224114aefa92a77b2f1c7b0d8.png"></p>
<pre><code>tftp通讯总结：
    1、服务器在69号端口等待客户端请求。
    2、服务器若批准此请求，则使用临时端口与客户端进行通信。
    3、每个数据包的编号都有变化（从1开始）。
    4、每个数据包都要得到ACK的缺认，如果出现超时，则需要
    重新发送最够的包（数据或者ACK）。
    5、数据包的长度以521byte传输。
    6、小于512byte的数据意味着传输结束。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/067c7b99eed6491ca72d318ce376fac2.png"></p>
<pre><code>    以上的0代表的是‘\0’。不同的差错码对应不同的错误信息。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/a298f86db91446cca4595708a9fb0ddb.png"></p>
<h2 id="5-11、使用TFTP下载"><a href="#5-11、使用TFTP下载" class="headerlink" title="5-11、使用TFTP下载"></a>5-11、使用TFTP下载</h2><pre><code>要求：使用tftp协议，下载server上的文件到本地。
思路：
    1、构造请求报文，发送到69端口。
    2、等待服务器回应。
    3、分析服务器回应。
    4、接收数据，直到数据小于512字节。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2651a13cebea43b5824f7b569285a4fa.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;  /**** printf ***/</span><br><span class="line">#include &lt;stdlib.h&gt; /**  exit  **/</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt; /** socket **/</span><br><span class="line">#include &lt;sys/socket.h&gt; /**  sockaddr_in **/</span><br><span class="line">#include &lt;arpa/inet.h&gt; /** htons inet_addr **/</span><br><span class="line">#include &lt;unistd.h&gt; /** close**/</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">void download(int sockfd,struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[128] = &quot;&quot;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名:\r\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,filename);</span><br><span class="line">    unsigned char text[1024] = &quot;&quot;;</span><br><span class="line">    int text_len;</span><br><span class="line">    socklen_t addrlen = sizeof(struct sockaddr_in);</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num =0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    /********* 构建发给服务器的tftp指令，如：01test.txt0octet0 ***************/</span><br><span class="line">    text_len = sprintf(text,&quot;%c%c%s%c%s%c&quot;,0,1,filename,0,&quot;octet&quot;,0);//////////////////</span><br><span class="line">    if(sendto(sockfd,text,text_len,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;fail to sendto&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        /*** 接收服务器发来的信息并处理****/</span><br><span class="line">        bytes = recvfrom(sockfd,text,sizeof(text),0,(struct sockaddr *)&amp;serveraddr,&amp;addrlen);</span><br><span class="line">        if(bytes == -1)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;recvfrom_filed&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        /*** 判断操作码*****/</span><br><span class="line">        if(text[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">        printf(&quot;error:%s\n&quot;,text+4);</span><br><span class="line">        return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(text[1] == 3)</span><br><span class="line">       &#123;</span><br><span class="line">         &#123;</span><br><span class="line">            if(flags == 0)/*** 创建文件的，flags为标志位，防止重复创建***/</span><br><span class="line">            &#123;/**创建文件***/</span><br><span class="line">                if((fd = open(filename,O_WRONLY | O_CREAT | O_TRUNC,0664)) &lt; 0) </span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;failed_open&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flags = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        /**  对比块编号和接收的数据大小并将文件内容写入文件***/</span><br><span class="line">        if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes == 516))/** 接收到的数据包还要加上操作码和块编号，所以是516 ***/</span><br><span class="line">            &#123;</span><br><span class="line">                num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen))</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to send&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if((num + 1 ==ntohs(*(unsigned short *)(text + 2)))&amp;&amp;(bytes &lt; 516))/**判断是否是最后一次传输**/</span><br><span class="line">            &#123; </span><br><span class="line">                 num = ntohs(*(unsigned short *)(text + 2));</span><br><span class="line">                if(write(fd,text + 4,bytes - 4) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    perror(&quot;fail to write&quot;);</span><br><span class="line">                    exit(1);</span><br><span class="line">                &#125;</span><br><span class="line">                text[1] = 4;</span><br><span class="line">                if(sendto(sockfd,text,4,0,(struct sockaddr *)&amp;serveraddr,addrlen) &lt; 0)</span><br><span class="line">                   &#123;</span><br><span class="line">                        perror(&quot;failed_sento&quot;);</span><br><span class="line">                        exit(1);</span><br><span class="line">                    &#125;</span><br><span class="line">                printf(&quot;文件下载完成\r\n&quot;);</span><br><span class="line">                return ;</span><br><span class="line">            &#125; </span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /** 创建套接字 **/</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;sockfd_fail\r\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /*** 填充服务器信息结构体 **/</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);/*** tftp服务器端地址 ***/</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line">   // if(bind(sockfd,(struct sockaddr *)&amp;serveraddr,sizeof(serveraddr)) == -1)</span><br><span class="line">   // &#123;</span><br><span class="line">    //    perror(&quot;bind_fail\r\n&quot;);</span><br><span class="line">   //    exit(1);   </span><br><span class="line">   // &#125;</span><br><span class="line">    /*** 下载 ***/</span><br><span class="line">    download(sockfd,serveraddr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>以下是上传服务器的代码
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line">上传服务器</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;arpa/inet.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define ERRLOG(errmsg) do&#123;\</span><br><span class="line">                            perror(errmsg);\</span><br><span class="line">                            exit(1);\</span><br><span class="line">                        &#125;while(0)</span><br><span class="line"></span><br><span class="line">#define N 128</span><br><span class="line"></span><br><span class="line">void do_help()</span><br><span class="line">&#123;</span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">    printf(&quot;------ 1. 下载 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 2. 上传 ------\n&quot;);</span><br><span class="line">    printf(&quot;------ 3. 退出 ------\n&quot;);</span><br><span class="line">    printf(&quot;---------------------\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_download(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要下载的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    char data[1024] = &quot;&quot;;</span><br><span class="line">    int data_len;</span><br><span class="line">    int fd;</span><br><span class="line">    int flags = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int recv_len;</span><br><span class="line"></span><br><span class="line">    //组数据并发送</span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 1, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收数据并分析处理</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %u\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 5)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;error: %s\n&quot;, data + 4);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(data[1] == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            //防止文件内容清空</span><br><span class="line">            if(flags == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if((fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0664)) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                flags = 1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //判断数据包的编号是否是上一次的编号加1</span><br><span class="line">            if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len == 516)</span><br><span class="line">            &#123;</span><br><span class="line">                //向文件写入数据</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">            </span><br><span class="line">                //组数据发送给服务器</span><br><span class="line">                data[1] = 4; </span><br><span class="line">                if(sendto(sockfd, data, 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                num = ntohs(*(unsigned short *)(data + 2));</span><br><span class="line">            &#125;</span><br><span class="line">            //接收到的最后一次的数据</span><br><span class="line">            else if(num + 1 == ntohs(*(unsigned short *)(data + 2)) &amp;&amp; recv_len &lt; 516)</span><br><span class="line">            &#123;</span><br><span class="line">                write(fd, data + 4, recv_len - 4);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件下载成功\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void do_upload(int sockfd, struct sockaddr_in serveraddr)</span><br><span class="line">&#123;</span><br><span class="line">    char filename[N] = &#123;&#125;;</span><br><span class="line">    printf(&quot;请输入要上传的文件名：&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;, filename);</span><br><span class="line"></span><br><span class="line">    //打开文件并判断文件是否存在</span><br><span class="line">    int fd;</span><br><span class="line">    if((fd = open(filename, O_RDONLY)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if(errno == ENOENT)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;文件%s不存在，请重新输入\n&quot;, filename);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to open&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //组数据并发送给服务器执行上传功能</span><br><span class="line">    char data[1024] = &#123;&#125;;</span><br><span class="line">    int data_len;</span><br><span class="line">    socklen_t addrlen = sizeof(serveraddr);</span><br><span class="line"></span><br><span class="line">    data_len = sprintf(data, &quot;%c%c%s%c%s%c&quot;, 0, 2, filename, 0, &quot;octet&quot;, 0);</span><br><span class="line"></span><br><span class="line">    if(sendto(sockfd, data, data_len, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //接收服务器发送的数据并分析处理</span><br><span class="line">    int recv_len;</span><br><span class="line">    int num = 0;</span><br><span class="line">    ssize_t bytes;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if((recv_len = recvfrom(sockfd, data, sizeof(data), 0, (struct sockaddr *)&amp;serveraddr, &amp;addrlen)) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ERRLOG(&quot;fail to recvfrom&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //printf(&quot;%d - %d\n&quot;, data[1], ntohs(*(unsigned short *)(data + 2)));</span><br><span class="line">        //printf(&quot;%s\n&quot;, data + 4);</span><br><span class="line"></span><br><span class="line">        if(data[1] == 4 &amp;&amp; num == ntohs(*(unsigned short *)(data + 2)))</span><br><span class="line">        &#123;</span><br><span class="line">            num++;</span><br><span class="line">            bytes = read(fd, data + 4, 512);</span><br><span class="line">            data[1] = 3;</span><br><span class="line">            *(unsigned short *)(data + 2) = htons(num);</span><br><span class="line"></span><br><span class="line">            if(bytes == 512)</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(sendto(sockfd, data, bytes + 4, 0, (struct sockaddr *)&amp;serveraddr, addrlen) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    ERRLOG(&quot;fail to sendto&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;文件上传完毕\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in serveraddr;</span><br><span class="line">    //创建套接字</span><br><span class="line">    if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        ERRLOG(&quot;fail to socket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //填充服务器网络信息结构体</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    serveraddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    serveraddr.sin_port = htons(69);</span><br><span class="line"></span><br><span class="line">    system(&quot;clear&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;----请输入help查看帮助信息----\n&quot;);</span><br><span class="line">    printf(&quot;------------------------------\n&quot;);</span><br><span class="line">    printf(&quot;&gt;&gt;&gt; &quot;);</span><br><span class="line"></span><br><span class="line">    char buf[N] = &#123;&#125;;</span><br><span class="line">NEXT:</span><br><span class="line">    fgets(buf, N, stdin);</span><br><span class="line">    buf[strlen(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">    if(strncmp(buf, &quot;help&quot;, 4) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        do_help();</span><br><span class="line">    &#125;</span><br><span class="line">    else </span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">        goto NEXT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int num;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;input&gt;&gt;&gt; &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;num);</span><br><span class="line">        switch (num)</span><br><span class="line">        &#123;</span><br><span class="line">        case 1:</span><br><span class="line">            do_download(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            do_upload(sockfd, serveraddr);</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            close(sockfd);</span><br><span class="line">            exit(0);</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            printf(&quot;您输入的有误，请重新输入\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6、udp广播"><a href="#6、udp广播" class="headerlink" title="6、udp广播"></a>6、udp广播</h1><pre><code>    广播： 由一台主机向该主机所在子网内的所有主机发送数据的方式。
    广播只能用 UDP 或原始 IP 实现， 不能用 TCP。
    
    用途：
    单个服务器与多个客户主机通信时减少分组流通。
    以下几个协议都用到广播
    1、 地址解析协议（ARP）。
    2、 动态主机配置协议（DHCP）。
    3、 网络时间协议（NTP）。

    特点：
        1、 处于同一子网的所有主机都必须处理数据。
        2、 UDP 数据包会沿协议栈向上一直到 UDP 层。
        3、 运行音视频等较高速率工作的应用， 会带来大负。
        4、 局限于局域网内使用。

    地址：
    &#123;网络 ID， 主机 ID&#125;
    网络 ID 表示由子网掩码中 1 覆盖的连续位。
    主机 ID 表示由子网掩码中 0 覆盖的连续位。
    定向广播地址： 主机 ID 全 1
    1、 例： 对于 192.168.220.0/24， 
    其定向广播地址为 192.168.220.255。
    2、 通常路由器不转发该广播
    受限广播地址： 255.255.255.255，
    路由器从不转发该广播。
</code></pre>
<h2 id="6-1、单播"><a href="#6-1、单播" class="headerlink" title="6-1、单播"></a>6-1、单播</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9c48ff8e0c7545f18f9a8ac94c1568aa.png"></p>
<h2 id="6-2、广播"><a href="#6-2、广播" class="headerlink" title="6-2、广播"></a>6-2、广播</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/0ab9e4650db64d47afc2c2fabf4e64e6.png"></p>
<h2 id="6-3、广播流程"><a href="#6-3、广播流程" class="headerlink" title="6-3、广播流程"></a>6-3、广播流程</h2><pre><code>    发送者：
    第一步：创建套接字 socket()
    第二步：设置为允许发送广播权限 setsockopt()
    第三步：向广播地址发送数据 sendto()

    接收者：
    第一步：创建套接字 socket()		
    第二步：将套接字与广播的信息结构体绑定 bind()
    第三步：接收数据 recvfrom()
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3f72e370b170408ba1329af3e9fcbfe6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">套接字选项</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);</span><br><span class="line">功能：设置一个套接字的选项（属性）</span><br><span class="line"> 参数：</span><br><span class="line"> socket：文件描述符</span><br><span class="line"> level：协议层次</span><br><span class="line"> SOL_SOCKET 套接字层次</span><br><span class="line"> IPPROTO_TCP tcp层次</span><br><span class="line"> IPPROTO_IP IP层次</span><br><span class="line"> option_name：选项的名称</span><br><span class="line"> SO_BROADCAST 允许发送广播数据（SOL_SOCKET层次的）</span><br><span class="line"> option_value：设置的选项的值</span><br><span class="line"> int类型的值，存储的是bool的数据（1和0）</span><br><span class="line"> 0 不允许</span><br><span class="line"> 1 允许</span><br><span class="line">option_len：option_value的长度</span><br><span class="line"> 返回值：</span><br><span class="line">成功：0</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<h3 id="6-3-1、发送者"><a href="#6-3-1、发送者" class="headerlink" title="6-3-1、发送者"></a>6-3-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//广播发送者代码实现</span><br><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s\r\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    socklen_t addrlen = sizeof(sendaddr);</span><br><span class="line">    int on = 1;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET , SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**SOL_SOCKET：协议层次**/</span><br><span class="line">    /** SO_BROADCAST：允许发送广播权限**/</span><br><span class="line">    /**on：设置是否允许，设置为1表示允许，0表示不允许**/</span><br><span class="line">    if(setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST,&amp;on,sizeof(on)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sersockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**绑定广播结构体**/    </span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line"></span><br><span class="line">    /**进行通讯**/</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,sizeof(buf),stdin);</span><br><span class="line">        buf[strlen(buf)-1] = &#x27;\0&#x27;; /**将输入完的数据用 \0 结尾**/</span><br><span class="line">        if(sendto(sockfd, buf, sizeof(buf), 0,(struct sockaddr *)&amp;sendaddr, addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-2、接收者"><a href="#6-3-2、接收者" class="headerlink" title="6-3-2、接收者"></a>6-3-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 2)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using = %s&quot;, argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in broadrecv;</span><br><span class="line">    socklen_t socklen;</span><br><span class="line">    /**创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_sockfd&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /**填充信息结构体**/</span><br><span class="line">    broadrecv.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    broadrecv.sin_family = AF_INET;</span><br><span class="line">    broadrecv.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    /**将信息结构体与结构体绑定**/</span><br><span class="line">    socklen = sizeof(broadrecv);</span><br><span class="line">    if(bind(sockfd,(struct sockaddr *)&amp;broadrecv,socklen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;/**这里还要在申请的原因是要那来接受发送者的信息**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, buf, sizeof(buf), 0 ,(struct sockaddr *)&amp;sendaddr, &amp;socklen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">       //     exit(1);</span><br><span class="line">        &#125; </span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;, inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<pre><code>    接收者只能有一个，发送者可以有多个。
</code></pre>
<h1 id="7、多播"><a href="#7、多播" class="headerlink" title="7、多播"></a>7、多播</h1><h2 id="7-1、概念"><a href="#7-1、概念" class="headerlink" title="7-1、概念"></a>7-1、概念</h2><pre><code>数据的收发只在同一分组中进行。所以多播又称之为组播。
多播的特点：
    1、多播地址标示一组接口。
    2、多播可以用于广域网使用。
    3、在ipv4中，多播是可选的。
    
</code></pre>
<h2 id="7-1、多播地址"><a href="#7-1、多播地址" class="headerlink" title="7-1、多播地址"></a>7-1、多播地址</h2><pre><code>ipv4的D类地址是多播地址。
多播地址向以太网mac地址的映射：
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/36714bc27d4f43a3873a84be62b12a47.png"></p>
<pre><code>    ipv4由32个字节构成，后23位组成以太网的都多播地址的底序23位，然后补一位0。
    广播的发送者必须要设置允许发送广播，而多播必须加入多播组，才能接收到信息。
</code></pre>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/acd963041bbd47e88d005546c3bb7576.png"></p>
<pre><code>注意：mac地址后23位由ipv4的后23位构成，
在接收者进行mac地址过滤的时候，进行的是不完全过滤，
原因就在于23位前面有一位被指0，导致可能的错误，所以
会在ipv4进行再次的过滤。比起广播，多播具有可控性，
只有加入多播组的接收者才能接收数据。
</code></pre>
<h2 id="7-2、多播的流程"><a href="#7-2、多播的流程" class="headerlink" title="7-2、多播的流程"></a>7-2、多播的流程</h2><pre><code>发送者：
    第一步：创建套接字socket。
    第二步：向多播地址发送数据sendto。
接收者：
    第一步：创建套接字socket。
    第二步：设置为加入多播组setsockopt（）。
    第三步：将套接字与多播信息结构体绑定。
    第四步：接收数据。
    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">多播地址结构体名字</span><br><span class="line">struct in_addr；</span><br><span class="line"></span><br><span class="line">struct ip_mreq;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/027660ee31f749ecbc7e1fd69de87a9b.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/451998d524cb4e27acd6698bc8308e64.png"></p>
<h3 id="7-2-1、发送者"><a href="#7-2-1、发送者" class="headerlink" title="7-2-1、发送者"></a>7-2-1、发送者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using : %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /**第一步，创建套接字**/</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;   </span><br><span class="line">    /********* ip地址必须设置为224.xxx.xxx.xxx 到239.... *********/</span><br><span class="line">    sendaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    sendaddr.sin_family = AF_INET;</span><br><span class="line">    sendaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    char buf[128] = &quot;&quot;;</span><br><span class="line">    addrlen = sizeof(sendaddr);</span><br><span class="line">    /**发送数据**/</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, sizeof(buf),stdin);</span><br><span class="line">        buf[sizeof(buf) - 1] = &#x27;\0&#x27;;</span><br><span class="line">        if(sendto(sockfd,buf,sizeof(buf),0,(struct sockaddr *)&amp;sendaddr,addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;sendto&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-2、接收者"><a href="#7-2-2、接收者" class="headerlink" title="7-2-2、接收者"></a>7-2-2、接收者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; //printf</span><br><span class="line">#include &lt;stdlib.h&gt; //exit</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt; //socket</span><br><span class="line">#include &lt;netinet/in.h&gt; //sockaddr_in</span><br><span class="line">#include &lt;arpa/inet.h&gt; //htons inet_addr</span><br><span class="line">#include &lt;unistd.h&gt; //close</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc,char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if(argc &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;using: %s&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    int sockfd;</span><br><span class="line">    socklen_t addrlen;</span><br><span class="line">    struct sockaddr_in recaddr;</span><br><span class="line">    </span><br><span class="line">    /***创建套接字**/</span><br><span class="line">    sockfd = socket(AF_INET, SOCK_DGRAM, 0);</span><br><span class="line">    if(sockfd &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    /***加入多播组**/</span><br><span class="line">    struct ip_mreq mreq;</span><br><span class="line">    mreq.imr_multiaddr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    /** INADDR_ANY表示任意主机**/</span><br><span class="line">    mreq.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line">    if(setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_setsockopt&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    recaddr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    recaddr.sin_family = AF_INET;</span><br><span class="line">    recaddr.sin_port = htons(atoi(argv[2]));</span><br><span class="line">    addrlen = sizeof(recaddr);</span><br><span class="line">    /**绑定组播信息结构体**/</span><br><span class="line">    if(bind(sockfd, (struct sockaddr *)&amp;recaddr, addrlen) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;failed_bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;  </span><br><span class="line">    /** 进行通信***/</span><br><span class="line">    char text[128] = &quot;&quot;;</span><br><span class="line">    struct sockaddr_in sendaddr;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        if(recvfrom(sockfd, text, sizeof(text), 0 , (struct sockaddr *)&amp;sendaddr,&amp;addrlen) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;failed_recvfrom&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;[%s - %d] : %s\r\n&quot;,inet_ntoa(sendaddr.sin_addr),ntohs(sendaddr.sin_port),text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="8、tcp"><a href="#8、tcp" class="headerlink" title="8、tcp"></a>8、tcp</h1><h2 id="8-1、tcp与udp对比"><a href="#8-1、tcp与udp对比" class="headerlink" title="8-1、tcp与udp对比"></a>8-1、tcp与udp对比</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/b48ee2f7f54843529407fba2c6ccdbc8.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/f8d0ff07fd604b44bd739194e6dffdc3.png"></p>
<h2 id="8-2、流程"><a href="#8-2、流程" class="headerlink" title="8-2、流程"></a>8-2、流程</h2><pre><code>服务器：
    创建套接字socket（）。
    将套接字与服务器网络信息结构体绑定。
    将套接字设置为监听状态listen（）。
    阻塞等待客户端的连接请求accept（）。
    进行通信recv（）/send（）。
    关闭套接字close（）。

客户端：
    创建套接字socket（）。
    发送客户端连接请求connect（）。
    进行通信send（）/recv（）。
    关闭套接字close。
    
1、这里的socket的要使用的tcp的参数。
2、connect作用是跟服务器建立连接，
    连接成功后才可以进行tcp的数据传输。
    连接成功后不会产生新的套接字。
3、send函数，ssize_t send(int sockfd, const void *buf, size_t len, int flags);
功能用于发送数据。
    
以下为各个函数的详细介绍：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> int socket(int domain, int type, int protocol);</span><br><span class="line"> 功能：创建一个套接字，返回一个文件描述符</span><br><span class="line"> 参数：</span><br><span class="line"> domain：通信域，协议族</span><br><span class="line"> AF_UNIX 本地通信</span><br><span class="line"> AF_INET ipv4网络协议</span><br><span class="line"> AF_INET6 ipv6网络协议</span><br><span class="line"> AF_PACKET 底层接口</span><br><span class="line"> type：套接字的类型</span><br><span class="line"> SOCK_STREAM 流式套接字（tcp）</span><br><span class="line"> SOCK_DGRAM 数据报套接字（udp）</span><br><span class="line"> SOCK_RAW 原始套接字（用于链路层）</span><br><span class="line"> protocol：附加协议，如果不需要，则设置为0</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：文件描述符</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">connect函数：</span><br><span class="line">#include &lt;sys/types.h&gt; </span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br><span class="line">功能：给服务器发送客户端的连接请求</span><br><span class="line">参数：</span><br><span class="line">sockfd：文件描述符，socket函数的返回值</span><br><span class="line">addr：要连接的服务器的网络信息结构体（需要自己设置）</span><br><span class="line">addrlen：add的长度</span><br><span class="line">返回值：</span><br><span class="line">成功：0</span><br><span class="line">失败：‐1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t send(int sockfd, const void *buf, size_t len, int flags);</span><br><span class="line"> 功能：发送数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：发送的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line"> 成功：发送的字节数</span><br><span class="line"> 失败：‐1</span><br></pre></td></tr></table></figure>
<pre><code>    注意：不能用tcp协议发送0长度的数据包。
    
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"> #include &lt;sys/socket.h&gt;</span><br><span class="line"> ssize_t recv(int sockfd, void *buf, size_t len, int flags);</span><br><span class="line"> 功能：接收数据</span><br><span class="line"> 参数：</span><br><span class="line"> sockfd：文件描述符</span><br><span class="line"> 客户端：socket函数的返回值</span><br><span class="line"> 服务器：accept函数的返回值</span><br><span class="line"> buf：保存接收到的数据</span><br><span class="line"> len：buf的长度</span><br><span class="line"> flags：标志位</span><br><span class="line"> 0 阻塞</span><br><span class="line"> MSG_DONTWAIT 非阻塞</span><br><span class="line"> 返回值：</span><br><span class="line">成功：接收的字节数</span><br><span class="line"> 失败：‐1</span><br><span class="line"> 如果发送端关闭文件描述符或者关闭进程，则recv函数会返回0</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://wesker-blog.github.io">wesker-yanggc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wesker-blog.github.io/posts/50daec4.html">https://wesker-blog.github.io/posts/50daec4.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wesker-blog.github.io" target="_blank">wesker-yanggc</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/2d150d9eaa2144b1b4746590c5253c6b.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/posts/ac405b50.html" title="报隐式函数的报错"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/921673ae1a194996af46815cecc8f986.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">报隐式函数的报错</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/3f85d3c8bd46405ab95747f19fcc1576.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wesker-yanggc</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95"><span class="toc-number">1.</span> <span class="toc-text">1、计算机网络发展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.1.</span> <span class="toc-text">1-1、数据交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1-2、交换方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3%E3%80%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.2.1.</span> <span class="toc-text">1-2-3、特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1-3、发展过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E8%8B%B1%E7%89%B9%E7%BD%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">2、英特网的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E4%B8%89%E7%BA%A7%E7%BB%93%E6%9E%84%E8%8B%B1%E7%89%B9%E7%BD%91"><span class="toc-number">2.1.</span> <span class="toc-text">2-1、三级结构英特网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E5%A4%9A%E7%BA%A7%E8%8B%B1%E7%89%B9%E7%BD%91"><span class="toc-number">2.2.</span> <span class="toc-text">2-2、多级英特网</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">3.</span> <span class="toc-text">3、TCP&#x2F;IP协议族</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3-1、分层结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.</span> <span class="toc-text">3-2、 IP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81tcp%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3-3、tcp协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81udp%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3-4、udp协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81mac%E5%9C%B0%E5%9D%80"><span class="toc-number">3.5.</span> <span class="toc-text">3-5、mac地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81ip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.</span> <span class="toc-text">3-6、ip地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1%E3%80%81IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.6.1.</span> <span class="toc-text">3-6-1、IP地址的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-1%E3%80%81ipv4%E7%BB%84%E6%88%90"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">3-6-1-1、ipv4组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2%E3%80%81ip%E7%BB%84%E6%88%90"><span class="toc-number">3.6.2.</span> <span class="toc-text">3-6-2、ip组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3%E3%80%81ipv4%E7%9A%84%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%EF%BC%88%E4%BE%9D%E6%8D%AE%E5%89%8D8%E4%BD%8D%E8%BF%9B%E8%A1%8C%E5%8C%BA%E5%88%86%EF%BC%89"><span class="toc-number">3.6.3.</span> <span class="toc-text">3-6-3、ipv4的地址分类（依据前8位进行区分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4%E3%80%81%E7%A7%81%E6%9C%89ip"><span class="toc-number">3.6.4.</span> <span class="toc-text">3-6-4、私有ip</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-5%E3%80%81%E5%9B%9E%E7%8E%AFip%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.5.</span> <span class="toc-text">3-6-5、回环ip地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-6%E3%80%81%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">3.6.6.</span> <span class="toc-text">3-6-6、子网掩码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7%E3%80%81%E7%AB%AF%E5%8F%A3"><span class="toc-number">3.7.</span> <span class="toc-text">3-7、端口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1%E3%80%81%E7%AB%AF%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">3.7.1.</span> <span class="toc-text">3-7-1、端口概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2%E3%80%81%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">3.7.2.</span> <span class="toc-text">3-7-2、端口号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3%E3%80%81%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B0%81%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.7.3.</span> <span class="toc-text">3-7-3、链路层封包格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-4%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%B0%81%E8%A3%85"><span class="toc-number">3.7.4.</span> <span class="toc-text">3-7-4、网络层的数据报封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8%E3%80%81c-x2F-s%E6%9E%B6%E6%9E%84"><span class="toc-number">3.8.</span> <span class="toc-text">3-8、c&#x2F;s架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E5%AD%97%E8%8A%82%E5%BA%8F%E3%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">4、字节序、地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E5%AD%97%E5%BA%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.</span> <span class="toc-text">4-1、字序转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">4-2、地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1%E3%80%81%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B01"><span class="toc-number">4.2.1.</span> <span class="toc-text">4-2-1、转换函数1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2%E3%80%81%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B02"><span class="toc-number">4.2.2.</span> <span class="toc-text">4-2-2、转换函数2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81udp"><span class="toc-number">5.</span> <span class="toc-text">5、udp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3socket"><span class="toc-number">5.1.</span> <span class="toc-text">5-1、网络编程接口socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81ipv4%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">5-2、ipv4套接字的地址结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%91%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">5.3.</span> <span class="toc-text">5-3、服务器向客户端发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4%E3%80%81%E7%BB%91%E5%AE%9A%E2%80%93bind%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">5-4、绑定–bind函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5%E3%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE-recvfrom"><span class="toc-number">5.5.</span> <span class="toc-text">5-5、接收数据-recvfrom</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">5.6.</span> <span class="toc-text">5-6、客户端向服务器发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7%E3%80%81c-x2F-s%E6%9E%B6%E6%9E%84"><span class="toc-number">5.7.</span> <span class="toc-text">5-7、c&#x2F;s架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8%E3%80%81udp%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">5.8.</span> <span class="toc-text">5-8、udp客户端注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">5.9.</span> <span class="toc-text">5-9、服务器注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-10%E3%80%81TFTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.10.</span> <span class="toc-text">5-10、TFTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-11%E3%80%81%E4%BD%BF%E7%94%A8TFTP%E4%B8%8B%E8%BD%BD"><span class="toc-number">5.11.</span> <span class="toc-text">5-11、使用TFTP下载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81udp%E5%B9%BF%E6%92%AD"><span class="toc-number">6.</span> <span class="toc-text">6、udp广播</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E5%8D%95%E6%92%AD"><span class="toc-number">6.1.</span> <span class="toc-text">6-1、单播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E5%B9%BF%E6%92%AD"><span class="toc-number">6.2.</span> <span class="toc-text">6-2、广播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E5%B9%BF%E6%92%AD%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">6-3、广播流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1%E3%80%81%E5%8F%91%E9%80%81%E8%80%85"><span class="toc-number">6.3.1.</span> <span class="toc-text">6-3-1、发送者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2%E3%80%81%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">6.3.2.</span> <span class="toc-text">6-3-2、接收者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%A4%9A%E6%92%AD"><span class="toc-number">7.</span> <span class="toc-text">7、多播</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">7-1、概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81%E5%A4%9A%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">7.2.</span> <span class="toc-text">7-1、多播地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E5%A4%9A%E6%92%AD%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">7-2、多播的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1%E3%80%81%E5%8F%91%E9%80%81%E8%80%85"><span class="toc-number">7.3.1.</span> <span class="toc-text">7-2-1、发送者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2%E3%80%81%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">7.3.2.</span> <span class="toc-text">7-2-2、接收者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81tcp"><span class="toc-number">8.</span> <span class="toc-text">8、tcp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81tcp%E4%B8%8Eudp%E5%AF%B9%E6%AF%94"><span class="toc-number">8.1.</span> <span class="toc-text">8-1、tcp与udp对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2%E3%80%81%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">8-2、流程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e2fc93b1.html" title="xml语法规则"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/12e11361c61d422a9e5c5335d6cb035c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="xml语法规则"/></a><div class="content"><a class="title" href="/posts/e2fc93b1.html" title="xml语法规则">xml语法规则</a><time datetime="2023-03-27T17:36:17.988Z" title="发表于 2023-03-28 01:36:17">2023-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e33939ec.html" title="机器视觉、音视频开发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/31fe5e0abc8644d39ba65c486f63a573.gif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器视觉、音视频开发"/></a><div class="content"><a class="title" href="/posts/e33939ec.html" title="机器视觉、音视频开发">机器视觉、音视频开发</a><time datetime="2023-03-16T08:28:56.484Z" title="发表于 2023-03-16 16:28:56">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/835d4465.html" title="vscode和source insight的快捷键"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/487d0fdbe3fc40258efec92919372cd0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vscode和source insight的快捷键"/></a><div class="content"><a class="title" href="/posts/835d4465.html" title="vscode和source insight的快捷键">vscode和source insight的快捷键</a><time datetime="2023-03-03T02:59:39.348Z" title="发表于 2023-03-03 10:59:39">2023-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/643bdf5f.html" title="挂载根文件系统出现错误"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/bb80e98485e349b1aef5268f3d086018.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="挂载根文件系统出现错误"/></a><div class="content"><a class="title" href="/posts/643bdf5f.html" title="挂载根文件系统出现错误">挂载根文件系统出现错误</a><time datetime="2023-03-02T06:05:43.857Z" title="发表于 2023-03-02 14:05:43">2023-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7a4978d4.html" title="进程的退出及信息打印"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4d759ae45f8d45c196e71c3090247640.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程的退出及信息打印"/></a><div class="content"><a class="title" href="/posts/7a4978d4.html" title="进程的退出及信息打印">进程的退出及信息打印</a><time datetime="2023-03-01T04:17:53.763Z" title="发表于 2023-03-01 12:17:53">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wesker-yanggc</div><div class="footer_custom_text">未经本人同意不得作于其他用途</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://wesker-blog.github.io/categories/驱动/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 驱动 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wesker-blog.github.io/categories/Linux开发/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Linux开发 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wesker-blog.github.io/categories/错误/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 错误 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wesker-blog.github.io/categories/其他/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 其他 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://wesker-blog.github.io/categories/AI学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 AI学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://wesker-blog.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/835d4465.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/487d0fdbe3fc40258efec92919372cd0.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-03</span><a class="blog-slider__title" href="posts/835d4465.html" alt="">vscode和source insight的快捷键</a><div class="blog-slider__text">vscode和source insight的快捷键</div><a class="blog-slider__button" href="posts/835d4465.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/ac405b50.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/921673ae1a194996af46815cecc8f986.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-25</span><a class="blog-slider__title" href="posts/ac405b50.html" alt="">报隐式函数的报错</a><div class="blog-slider__text">工作学习过程中的错误解决方案</div><a class="blog-slider__button" href="posts/ac405b50.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/835d4465.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/9c676114cb2444428b8a0e9f53103093.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-25</span><a class="blog-slider__title" href="posts/835d4465.html" alt="">linux中断</a><div class="blog-slider__text">linux内核驱动知识点</div><a class="blog-slider__button" href="posts/835d4465.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/50daec4.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/2d150d9eaa2144b1b4746590c5253c6b.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-25</span><a class="blog-slider__title" href="posts/50daec4.html" alt="">网络</a><div class="blog-slider__text">计算机网络笔记</div><a class="blog-slider__button" href="posts/50daec4.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/7a4978d4.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/4d759ae45f8d45c196e71c3090247640.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-01</span><a class="blog-slider__title" href="posts/7a4978d4.html" alt="">进程的退出及信息打印</a><div class="blog-slider__text">exit，_exit ,abort,return 的区别联系及perror函数作用</div><a class="blog-slider__button" href="posts/7a4978d4.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/69453faf.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/8a451a21ee0e483abf9bcec6511ecbcd.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-02-28</span><a class="blog-slider__title" href="posts/69453faf.html" alt="">linux c 开发编程</a><div class="blog-slider__text">学习linux 开发的笔记</div><a class="blog-slider__button" href="posts/69453faf.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/643bdf5f.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/bb80e98485e349b1aef5268f3d086018.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-02</span><a class="blog-slider__title" href="posts/643bdf5f.html" alt="">挂载根文件系统出现错误</a><div class="blog-slider__text">工作学习过程中的错误解决方案</div><a class="blog-slider__button" href="posts/643bdf5f.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/e2fc93b1.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/12e11361c61d422a9e5c5335d6cb035c.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-28</span><a class="blog-slider__title" href="posts/e2fc93b1.html" alt="">xml语法规则</a><div class="blog-slider__text">工作过程中需要的知识</div><a class="blog-slider__button" href="posts/e2fc93b1.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/e33939ec.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/31fe5e0abc8644d39ba65c486f63a573.gif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-16</span><a class="blog-slider__title" href="posts/e33939ec.html" alt="">机器视觉、音视频开发</a><div class="blog-slider__text">IPC开发</div><a class="blog-slider__button" href="posts/e33939ec.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>